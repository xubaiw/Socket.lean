[{"name":"instHashableNat","description":""},{"name":"instHashableProd","description":""},{"name":"instHashableBool","description":""},{"name":"instHashableOption","description":""},{"name":"instHashableList","description":""},{"name":"instHashableUInt8","description":""},{"name":"instHashableUInt16","description":""},{"name":"instHashableUInt32","description":""},{"name":"instHashableUInt64","description":""},{"name":"instHashableUSize","description":""},{"name":"instHashableFin","description":""},{"name":"instHashableInt","description":""},{"name":"instHashable","description":""},{"name":"Nat.Linear.Var","description":"!\n  Helper definitions and theorems for constructing linear arithmetic proofs.\n"},{"name":"Nat.Linear.Context","description":""},{"name":"Nat.Linear.fixedVar","description":"When encoding polynomials. We use `fixedVar` for encoding numerals.\n  The denotation of `fixedVar` is always `1`. "},{"name":"Nat.Linear.Var.denote","description":""},{"name":"Nat.Linear.Var.denote.go","description":""},{"name":"Nat.Linear.Expr","description":""},{"name":"Nat.Linear.instInhabitedExpr","description":""},{"name":"Nat.Linear.Expr.denote","description":""},{"name":"Nat.Linear.Poly","description":""},{"name":"Nat.Linear.Poly.denote","description":""},{"name":"Nat.Linear.Poly.insertSorted","description":""},{"name":"Nat.Linear.Poly.sort","description":""},{"name":"Nat.Linear.Poly.sort.go","description":""},{"name":"Nat.Linear.Poly.fuse","description":""},{"name":"Nat.Linear.Poly.mul","description":""},{"name":"Nat.Linear.Poly.mul.go","description":""},{"name":"Nat.Linear.Poly.cancelAux","description":""},{"name":"Nat.Linear.hugeFuel","description":""},{"name":"Nat.Linear.Poly.cancel","description":""},{"name":"Nat.Linear.Poly.isNum?","description":""},{"name":"Nat.Linear.Poly.isZero","description":""},{"name":"Nat.Linear.Poly.isNonZero","description":""},{"name":"Nat.Linear.Poly.denote_eq","description":""},{"name":"Nat.Linear.Poly.denote_le","description":""},{"name":"Nat.Linear.Poly.combineAux","description":""},{"name":"Nat.Linear.Poly.combine","description":""},{"name":"Nat.Linear.Expr.toPoly","description":""},{"name":"Nat.Linear.Poly.norm","description":""},{"name":"Nat.Linear.Expr.toNormPoly","description":""},{"name":"Nat.Linear.Expr.inc","description":""},{"name":"Nat.Linear.PolyCnstr","description":""},{"name":"Nat.Linear.instBEqPolyCnstr","description":""},{"name":"Nat.Linear.instLawfulBEqPolyCnstrInstBEqPolyCnstr","description":""},{"name":"Nat.Linear.PolyCnstr.mul","description":""},{"name":"Nat.Linear.PolyCnstr.combine","description":""},{"name":"Nat.Linear.ExprCnstr","description":""},{"name":"Nat.Linear.PolyCnstr.denote","description":""},{"name":"Nat.Linear.PolyCnstr.norm","description":""},{"name":"Nat.Linear.PolyCnstr.isUnsat","description":""},{"name":"Nat.Linear.PolyCnstr.isValid","description":""},{"name":"Nat.Linear.ExprCnstr.denote","description":""},{"name":"Nat.Linear.ExprCnstr.toPoly","description":""},{"name":"Nat.Linear.ExprCnstr.toNormPoly","description":""},{"name":"Nat.Linear.Certificate","description":""},{"name":"Nat.Linear.Certificate.combineHyps","description":""},{"name":"Nat.Linear.Certificate.combine","description":""},{"name":"Nat.Linear.Certificate.denote","description":""},{"name":"Nat.Linear.monomialToExpr","description":""},{"name":"Nat.Linear.Poly.toExpr","description":""},{"name":"Nat.Linear.Poly.toExpr.go","description":""},{"name":"Nat.Linear.PolyCnstr.toExpr","description":""},{"name":"Nat.Linear.Poly.denote_insertSorted","description":""},{"name":"Nat.Linear.Poly.denote_sort_go","description":""},{"name":"Nat.Linear.Poly.denote_sort","description":""},{"name":"Nat.Linear.Poly.denote_append","description":""},{"name":"Nat.Linear.Poly.denote_cons","description":""},{"name":"Nat.Linear.Poly.denote_reverseAux","description":""},{"name":"Nat.Linear.Poly.denote_reverse","description":""},{"name":"Nat.Linear.Poly.denote_fuse","description":""},{"name":"Nat.Linear.Poly.denote_mul","description":""},{"name":"Nat.Linear.Poly.denote_eq_cancelAux","description":""},{"name":"Nat.Linear.Poly.of_denote_eq_cancelAux","description":""},{"name":"Nat.Linear.Poly.denote_eq_cancel","description":""},{"name":"Nat.Linear.Poly.of_denote_eq_cancel","description":""},{"name":"Nat.Linear.Poly.denote_eq_cancel_eq","description":""},{"name":"Nat.Linear.Poly.denote_le_cancelAux","description":""},{"name":"Nat.Linear.Poly.of_denote_le_cancelAux","description":""},{"name":"Nat.Linear.Poly.denote_le_cancel","description":""},{"name":"Nat.Linear.Poly.of_denote_le_cancel","description":""},{"name":"Nat.Linear.Poly.denote_le_cancel_eq","description":""},{"name":"Nat.Linear.Poly.denote_combineAux","description":""},{"name":"Nat.Linear.Poly.denote_combine","description":""},{"name":"Nat.Linear.Expr.denote_toPoly","description":""},{"name":"Nat.Linear.Expr.eq_of_toNormPoly","description":""},{"name":"Nat.Linear.Expr.of_cancel_eq","description":""},{"name":"Nat.Linear.Expr.of_cancel_le","description":""},{"name":"Nat.Linear.Expr.of_cancel_lt","description":""},{"name":"Nat.Linear.ExprCnstr.toPoly_norm_eq","description":""},{"name":"Nat.Linear.ExprCnstr.denote_toPoly","description":""},{"name":"Nat.Linear.ExprCnstr.denote_toNormPoly","description":""},{"name":"Nat.Linear.Poly.mul.go_denote","description":""},{"name":"Nat.Linear.PolyCnstr.denote_mul","description":""},{"name":"Nat.Linear.PolyCnstr.denote_combine","description":""},{"name":"Nat.Linear.Poly.isNum?_eq_some","description":""},{"name":"Nat.Linear.Poly.of_isZero","description":""},{"name":"Nat.Linear.Poly.of_isNonZero","description":""},{"name":"Nat.Linear.PolyCnstr.eq_false_of_isUnsat","description":""},{"name":"Nat.Linear.PolyCnstr.eq_true_of_isValid","description":""},{"name":"Nat.Linear.ExprCnstr.eq_false_of_isUnsat","description":""},{"name":"Nat.Linear.ExprCnstr.eq_true_of_isValid","description":""},{"name":"Nat.Linear.Certificate.of_combineHyps","description":""},{"name":"Nat.Linear.Certificate.of_combine","description":""},{"name":"Nat.Linear.Certificate.of_combine_isUnsat","description":""},{"name":"Nat.Linear.denote_monomialToExpr","description":""},{"name":"Nat.Linear.Poly.denote_toExpr_go","description":""},{"name":"Nat.Linear.Poly.denote_toExpr","description":""},{"name":"Nat.Linear.ExprCnstr.eq_of_toNormPoly_eq","description":""},{"name":"Nat.Linear.Expr.eq_of_toNormPoly_eq","description":""},{"name":"Socket.Socket.mk","description":"Create a new `Socket` using the specified domain and type.\n"},{"name":"Socket.Socket.close","description":"Close the `Socket`.\n\n  *NOTE:* Although Socket is designed to be automatically closed when garbage collected,\n  it's a good practice to manually close it beforehand.\n"},{"name":"Socket.Socket.connect","description":"Initiate a connection on a socket.\n"},{"name":"Socket.Socket.bind","description":"Bind a name to a socket.\n"},{"name":"Socket.Socket.listen","description":"Listen for connections on a socket.\n"},{"name":"Socket.Socket.accept","description":"Accept a connection on a socket.\n"},{"name":"Socket.Socket.send","description":"Send a message from a socket.\n"},{"name":"Socket.Socket.recv","description":"Receive a message from a socket.\n"},{"name":"Socket.Socket.sendto","description":"Send a message from a socket.\n"},{"name":"Socket.Socket.recvfrom","description":"Receive a message from a socket.\n"},{"name":"Socket.Socket.shutdown","description":"Shut down part of a full-duplex connection.\n"},{"name":"Socket.Socket.peer","description":"Get address of connected peer.\n"},{"name":"ReaderT.orElse","description":""},{"name":"ReaderT.failure","description":""},{"name":"ReaderT.instAlternativeReaderT","description":""},{"name":"instMonadControlReaderT","description":""},{"name":"ReaderT.tryFinally","description":""},{"name":"Reader","description":""},{"name":"StateT","description":""},{"name":"StateT.run","description":""},{"name":"StateT.run'","description":""},{"name":"StateM","description":""},{"name":"instSubsingletonStateM","description":""},{"name":"StateT.pure","description":""},{"name":"StateT.bind","description":""},{"name":"StateT.map","description":""},{"name":"StateT.instMonadStateT","description":""},{"name":"StateT.orElse","description":""},{"name":"StateT.failure","description":""},{"name":"StateT.instAlternativeStateT","description":""},{"name":"StateT.get","description":""},{"name":"StateT.set","description":""},{"name":"StateT.modifyGet","description":""},{"name":"StateT.lift","description":""},{"name":"StateT.instMonadLiftStateT","description":""},{"name":"StateT.instMonadFunctorStateT","description":""},{"name":"StateT.instMonadExceptOfStateT","description":""},{"name":"instMonadStateOfStateT","description":""},{"name":"StateT.monadControl","description":""},{"name":"StateT.tryFinally","description":""},{"name":"ByteArray","description":""},{"name":"ByteArray.mkEmpty","description":""},{"name":"ByteArray.empty","description":""},{"name":"ByteArray.instInhabitedByteArray","description":""},{"name":"ByteArray.instEmptyCollectionByteArray","description":""},{"name":"ByteArray.push","description":""},{"name":"ByteArray.size","description":""},{"name":"ByteArray.uget","description":""},{"name":"ByteArray.get!","description":""},{"name":"ByteArray.get","description":""},{"name":"ByteArray.getOp","description":""},{"name":"ByteArray.set!","description":""},{"name":"ByteArray.set","description":""},{"name":"ByteArray.uset","description":""},{"name":"ByteArray.isEmpty","description":""},{"name":"ByteArray.copySlice","description":"Copy the slice at `[srcOff, srcOff + len)` in `src` to `[destOff, destOff + len)` in `dest`, growing `dest` if necessary.\n  If `exact` is `false`, the capacity will be doubled when grown. "},{"name":"ByteArray.extract","description":""},{"name":"ByteArray.append","description":""},{"name":"ByteArray.instAppendByteArray","description":""},{"name":"ByteArray.toList","description":""},{"name":"ByteArray.toList.loop","description":""},{"name":"ByteArray.findIdx?","description":""},{"name":"ByteArray.findIdx?.loop","description":""},{"name":"ByteArray.forInUnsafe","description":""},{"name":"ByteArray.forInUnsafe.loop","description":""},{"name":"ByteArray.forIn","description":""},{"name":"ByteArray.forIn.loop","description":""},{"name":"ByteArray.instForInByteArrayUInt8","description":""},{"name":"ByteArray.foldlMUnsafe","description":""},{"name":"ByteArray.foldlMUnsafe.fold","description":""},{"name":"ByteArray.foldlM","description":""},{"name":"ByteArray.foldlM.loop","description":""},{"name":"ByteArray.foldl","description":""},{"name":"List.toByteArray","description":""},{"name":"List.toByteArray.loop","description":""},{"name":"instToStringByteArray","description":""},{"name":"ByteArray.toUInt64LE!","description":"Interpret a `ByteArray` of size 8 as a little-endian `UInt64`. "},{"name":"ByteArray.toUInt64BE!","description":"Interpret a `ByteArray` of size 8 as a big-endian `UInt64`. "},{"name":"Coe","description":""},{"name":"CoeTC","description":"Auxiliary class that contains the transitive closure of `Coe`. "},{"name":"CoeHead","description":""},{"name":"CoeTail","description":""},{"name":"CoeHTCT","description":"Auxiliary class that contains `CoeHead` + `CoeTC` + `CoeTail`. "},{"name":"CoeDep","description":""},{"name":"CoeT","description":""},{"name":"CoeFun","description":""},{"name":"CoeSort","description":""},{"name":"coeNotation","description":""},{"name":"coeTrans","description":""},{"name":"coeBase","description":""},{"name":"coeOfHeafOfTCOfTail","description":""},{"name":"coeOfHeadOfTC","description":""},{"name":"coeOfTCOfTail","description":""},{"name":"coeOfHead","description":""},{"name":"coeOfTail","description":""},{"name":"coeOfTC","description":""},{"name":"coeOfHTCT","description":""},{"name":"coeOfDep","description":""},{"name":"coeId","description":""},{"name":"coeSortToCoeTail","description":""},{"name":"boolToProp","description":""},{"name":"boolToSort","description":""},{"name":"decPropToBool","description":""},{"name":"optionCoe","description":""},{"name":"subtypeCoe","description":""},{"name":"Lean.Internal.liftCoeM","description":""},{"name":"Lean.Internal.coeM","description":""},{"name":"instCoeDep","description":""},{"name":"instCoeTail","description":""},{"name":"instCoeTail_1","description":""},{"name":"Subarray","description":""},{"name":"Subarray.popFront","description":""},{"name":"Subarray.forInUnsafe","description":""},{"name":"Subarray.forInUnsafe.loop","description":""},{"name":"Subarray.forIn","description":""},{"name":"Subarray.instForInSubarray","description":""},{"name":"Subarray.foldlM","description":""},{"name":"Subarray.foldrM","description":""},{"name":"Subarray.anyM","description":""},{"name":"Subarray.allM","description":""},{"name":"Subarray.forM","description":""},{"name":"Subarray.forRevM","description":""},{"name":"Subarray.foldl","description":""},{"name":"Subarray.foldr","description":""},{"name":"Subarray.any","description":""},{"name":"Subarray.all","description":""},{"name":"Array.toSubarray","description":""},{"name":"Array.ofSubarray","description":""},{"name":"Array.extract","description":""},{"name":"Array.instCoeSubarrayArray","description":""},{"name":"Array.«term__[_:_]»","description":""},{"name":"Array.«term__[_:]»","description":""},{"name":"Array.«term__[:_]»","description":""},{"name":"Subarray.toArray","description":""},{"name":"instAppendSubarray","description":""},{"name":"instReprSubarray","description":""},{"name":"instToStringSubarray","description":""},{"name":"List.asString","description":""},{"name":"String.instLTString","description":""},{"name":"String.decLt","description":""},{"name":"String.length","description":""},{"name":"String.push","description":"The internal implementation uses dynamic arrays and will perform destructive updates\n   if the String is not shared. "},{"name":"String.append","description":"The internal implementation uses dynamic arrays and will perform destructive updates\n   if the String is not shared. "},{"name":"String.toList","description":"O(n) in the runtime, where n is the length of the String "},{"name":"String.get","description":""},{"name":"String.getOp","description":""},{"name":"String.set","description":""},{"name":"String.modify","description":""},{"name":"String.next","description":""},{"name":"String.prev","description":""},{"name":"String.front","description":""},{"name":"String.back","description":""},{"name":"String.atEnd","description":""},{"name":"String.posOfAux","description":""},{"name":"String.posOf","description":""},{"name":"String.revPosOfAux","description":""},{"name":"String.revPosOf","description":""},{"name":"String.findAux","description":""},{"name":"String.find","description":""},{"name":"String.revFindAux","description":""},{"name":"String.revFind","description":""},{"name":"String.firstDiffPos","description":"Returns the first position where the two strings differ. "},{"name":"String.firstDiffPos.loop","description":""},{"name":"String.extract","description":""},{"name":"String.splitAux","description":""},{"name":"String.split","description":""},{"name":"String.splitOnAux","description":""},{"name":"String.splitOn","description":""},{"name":"String.instInhabitedString","description":""},{"name":"String.instAppendString","description":""},{"name":"String.str","description":""},{"name":"String.pushn","description":""},{"name":"String.isEmpty","description":""},{"name":"String.join","description":""},{"name":"String.singleton","description":""},{"name":"String.intercalate","description":""},{"name":"String.intercalate.go","description":""},{"name":"String.Iterator","description":""},{"name":"String.instDecidableEqIterator","description":""},{"name":"String.mkIterator","description":""},{"name":"String.Iterator.toString","description":""},{"name":"String.Iterator.remainingBytes","description":""},{"name":"String.Iterator.pos","description":""},{"name":"String.Iterator.curr","description":""},{"name":"String.Iterator.next","description":""},{"name":"String.Iterator.prev","description":""},{"name":"String.Iterator.hasNext","description":""},{"name":"String.Iterator.hasPrev","description":""},{"name":"String.Iterator.setCurr","description":""},{"name":"String.Iterator.toEnd","description":""},{"name":"String.Iterator.extract","description":""},{"name":"String.Iterator.forward","description":""},{"name":"String.Iterator.remainingToString","description":""},{"name":"String.Iterator.nextn","description":""},{"name":"String.Iterator.prevn","description":""},{"name":"String.offsetOfPosAux","description":""},{"name":"String.offsetOfPos","description":""},{"name":"String.foldlAux","description":""},{"name":"String.foldlAux.loop","description":""},{"name":"String.foldl","description":""},{"name":"String.foldrAux","description":""},{"name":"String.foldrAux.loop","description":""},{"name":"String.foldr","description":""},{"name":"String.anyAux","description":""},{"name":"String.anyAux.loop","description":""},{"name":"String.any","description":""},{"name":"String.all","description":""},{"name":"String.contains","description":""},{"name":"String.mapAux","description":""},{"name":"String.map","description":""},{"name":"String.isNat","description":""},{"name":"String.toNat?","description":""},{"name":"String.substrEq","description":"Return `true` iff the substring of length `sz` starting at position `off1` in `s1` is equal to that starting at `off2` in `s2.`.\nFalse if either substring of that length does not exist. "},{"name":"String.substrEq.loop","description":""},{"name":"String.isPrefixOf","description":"Return true iff `p` is a prefix of `s` "},{"name":"String.replace","description":"Replace all occurrences of `pattern` in `s` with `replacment`. "},{"name":"String.replace.loop","description":""},{"name":"Substring.isEmpty","description":""},{"name":"Substring.toString","description":""},{"name":"Substring.toIterator","description":""},{"name":"Substring.get","description":"Return the codepoint at the given offset into the substring. "},{"name":"Substring.next","description":"Given an offset of a codepoint into the substring,\nreturn the offset there of the next codepoint. "},{"name":"Substring.prev","description":"Given an offset of a codepoint into the substring,\nreturn the offset there of the previous codepoint. "},{"name":"Substring.nextn","description":""},{"name":"Substring.prevn","description":""},{"name":"Substring.front","description":""},{"name":"Substring.posOf","description":"Return the offset into `s` of the first occurence of `c` in `s`,\nor `s.bsize` if `c` doesn't occur. "},{"name":"Substring.drop","description":""},{"name":"Substring.dropRight","description":""},{"name":"Substring.take","description":""},{"name":"Substring.takeRight","description":""},{"name":"Substring.atEnd","description":""},{"name":"Substring.extract","description":""},{"name":"Substring.splitOn","description":""},{"name":"Substring.splitOn.loop","description":""},{"name":"Substring.foldl","description":""},{"name":"Substring.foldr","description":""},{"name":"Substring.any","description":""},{"name":"Substring.all","description":""},{"name":"Substring.contains","description":""},{"name":"Substring.takeWhile","description":""},{"name":"Substring.dropWhile","description":""},{"name":"Substring.takeRightWhile","description":""},{"name":"Substring.dropRightWhile","description":""},{"name":"Substring.trimLeft","description":""},{"name":"Substring.trimRight","description":""},{"name":"Substring.trim","description":""},{"name":"Substring.isNat","description":""},{"name":"Substring.toNat?","description":""},{"name":"Substring.beq","description":""},{"name":"Substring.hasBeq","description":""},{"name":"String.drop","description":""},{"name":"String.dropRight","description":""},{"name":"String.take","description":""},{"name":"String.takeRight","description":""},{"name":"String.takeWhile","description":""},{"name":"String.dropWhile","description":""},{"name":"String.takeRightWhile","description":""},{"name":"String.dropRightWhile","description":""},{"name":"String.startsWith","description":""},{"name":"String.endsWith","description":""},{"name":"String.trimRight","description":""},{"name":"String.trimLeft","description":""},{"name":"String.trim","description":""},{"name":"String.nextWhile","description":""},{"name":"String.nextUntil","description":""},{"name":"String.toUpper","description":""},{"name":"String.toLower","description":""},{"name":"String.capitalize","description":""},{"name":"String.decapitalize","description":""},{"name":"Char.toString","description":""},{"name":"List.length_add_eq_lengthTRAux","description":""},{"name":"List.length_eq_lengthTR","description":""},{"name":"List.length_nil","description":""},{"name":"List.reverseAux","description":""},{"name":"List.reverse","description":""},{"name":"List.reverseAux_reverseAux_nil","description":""},{"name":"List.reverseAux_reverseAux","description":""},{"name":"List.reverse_reverse","description":""},{"name":"List.append","description":""},{"name":"List.appendTR","description":""},{"name":"List.append_eq_appendTR","description":""},{"name":"List.instAppendList","description":""},{"name":"List.nil_append","description":""},{"name":"List.append_nil","description":""},{"name":"List.cons_append","description":""},{"name":"List.List.append_eq","description":""},{"name":"List.append_assoc","description":""},{"name":"List.instEmptyCollectionList","description":""},{"name":"List.erase","description":""},{"name":"List.eraseIdx","description":""},{"name":"List.isEmpty","description":""},{"name":"List.map","description":""},{"name":"List.mapTRAux","description":""},{"name":"List.mapTR","description":""},{"name":"List.reverseAux_eq_append","description":""},{"name":"List.reverse_nil","description":""},{"name":"List.reverse_cons","description":""},{"name":"List.reverse_append","description":""},{"name":"List.mapTRAux_eq","description":""},{"name":"List.map_eq_mapTR","description":""},{"name":"List.map₂","description":""},{"name":"List.join","description":""},{"name":"List.filterMap","description":""},{"name":"List.filterAux","description":""},{"name":"List.filter","description":""},{"name":"List.partitionAux","description":""},{"name":"List.partition","description":""},{"name":"List.dropWhile","description":""},{"name":"List.find?","description":""},{"name":"List.findSome?","description":""},{"name":"List.replace","description":""},{"name":"List.elem","description":""},{"name":"List.notElem","description":""},{"name":"List.contains","description":""},{"name":"List.eraseDupsAux","description":""},{"name":"List.eraseDups","description":""},{"name":"List.eraseRepsAux","description":""},{"name":"List.eraseReps","description":"Erase repeated adjacent elements. "},{"name":"List.spanAux","description":""},{"name":"List.span","description":""},{"name":"List.groupByAux","description":""},{"name":"List.groupBy","description":""},{"name":"List.lookup","description":""},{"name":"List.removeAll","description":""},{"name":"List.drop","description":""},{"name":"List.take","description":""},{"name":"List.takeWhile","description":""},{"name":"List.foldr","description":""},{"name":"List.any","description":""},{"name":"List.all","description":""},{"name":"List.or","description":""},{"name":"List.and","description":""},{"name":"List.zipWith","description":""},{"name":"List.zip","description":""},{"name":"List.unzip","description":""},{"name":"List.rangeAux","description":""},{"name":"List.range","description":""},{"name":"List.iota","description":""},{"name":"List.iotaTR","description":""},{"name":"List.iotaTR.go","description":""},{"name":"List.iota_eq_iotaTR","description":""},{"name":"List.enumFrom","description":""},{"name":"List.enum","description":""},{"name":"List.init","description":""},{"name":"List.intersperse","description":""},{"name":"List.intercalate","description":""},{"name":"List.bind","description":""},{"name":"List.pure","description":""},{"name":"List.lt","description":""},{"name":"List.instLTList","description":""},{"name":"List.hasDecidableLt","description":""},{"name":"List.le","description":""},{"name":"List.instLEList","description":""},{"name":"List.instForAllListDecidableLeInstLEList","description":""},{"name":"List.isPrefixOf","description":"`isPrefixOf l₁ l₂` returns `true` Iff `l₁` is a prefix of `l₂`. "},{"name":"List.isSuffixOf","description":"`isSuffixOf l₁ l₂` returns `true` Iff `l₁` is a suffix of `l₂`. "},{"name":"List.isEqv","description":""},{"name":"List.beq","description":""},{"name":"List.instBEqList","description":""},{"name":"List.replicate","description":""},{"name":"List.replicateTR","description":""},{"name":"List.replicateTR.loop","description":""},{"name":"List.replicateTR_loop_replicate_eq","description":""},{"name":"List.replicate_eq_replicateTR","description":""},{"name":"List.dropLast","description":""},{"name":"List.length_replicate","description":""},{"name":"List.length_concat","description":""},{"name":"List.length_set","description":""},{"name":"List.length_dropLast","description":""},{"name":"List.length_append","description":""},{"name":"List.length_reverse","description":""},{"name":"List.maximum?","description":""},{"name":"List.minimum?","description":""},{"name":"List.instLawfulBEqListInstBEqList","description":""},{"name":"termS!_","description":""},{"name":"Socket.SockAddr.mk","description":"Create a [`SockAddr`](##Socket.SockAddr). "},{"name":"Socket.SockAddr.family","description":"Get family of the [`SockAddr`](##Socket.SockAddr). "},{"name":"Socket.SockAddr.port","description":"Get family of the [`SockAddr`](##Socket.SockAddr). "},{"name":"Socket.SockAddr.host","description":"Get family of the [`SockAddr`](##Socket.SockAddr). "},{"name":"Socket.instToStringSockAddr","description":"Convert [`SockAddr`](##Socket.SockAddr) to `String`. "},{"name":"Nat.foldAux","description":""},{"name":"Nat.fold","description":""},{"name":"Nat.foldRev","description":""},{"name":"Nat.foldRev.loop","description":""},{"name":"Nat.anyAux","description":""},{"name":"Nat.any","description":""},{"name":"Nat.all","description":""},{"name":"Nat.repeat","description":""},{"name":"Nat.repeat.loop","description":""},{"name":"Nat.blt","description":""},{"name":"Nat.zero_eq","description":""},{"name":"Nat.add_eq","description":""},{"name":"Nat.mul_eq","description":""},{"name":"Nat.sub_eq","description":""},{"name":"Nat.lt_eq","description":""},{"name":"Nat.le_eq","description":""},{"name":"Nat.beq_refl","description":""},{"name":"Nat.beq_eq","description":""},{"name":"Nat.ble_eq","description":""},{"name":"Nat.blt_eq","description":""},{"name":"Nat.instLawfulBEqNatInstBEqNat","description":""},{"name":"Nat.beq_eq_true_eq","description":""},{"name":"Nat.not_beq_eq_true_eq","description":""},{"name":"Nat.zero_add","description":""},{"name":"Nat.succ_add","description":""},{"name":"Nat.add_succ","description":""},{"name":"Nat.add_one","description":""},{"name":"Nat.succ_eq_add_one","description":""},{"name":"Nat.add_comm","description":""},{"name":"Nat.add_assoc","description":""},{"name":"Nat.add_left_comm","description":""},{"name":"Nat.add_right_comm","description":""},{"name":"Nat.add_left_cancel","description":""},{"name":"Nat.add_right_cancel","description":""},{"name":"Nat.mul_zero","description":""},{"name":"Nat.mul_succ","description":""},{"name":"Nat.zero_mul","description":""},{"name":"Nat.succ_mul","description":""},{"name":"Nat.mul_comm","description":""},{"name":"Nat.mul_one","description":""},{"name":"Nat.one_mul","description":""},{"name":"Nat.left_distrib","description":""},{"name":"Nat.right_distrib","description":""},{"name":"Nat.mul_add","description":""},{"name":"Nat.add_mul","description":""},{"name":"Nat.mul_assoc","description":""},{"name":"Nat.mul_left_comm","description":""},{"name":"Nat.succ_lt_succ","description":""},{"name":"Nat.lt_succ_of_le","description":""},{"name":"Nat.sub_zero","description":""},{"name":"Nat.succ_sub_succ_eq_sub","description":""},{"name":"Nat.pred_le","description":""},{"name":"Nat.pred_lt","description":""},{"name":"Nat.sub_le","description":""},{"name":"Nat.sub_lt","description":""},{"name":"Nat.sub_succ","description":""},{"name":"Nat.succ_sub_succ","description":""},{"name":"Nat.sub_self","description":""},{"name":"Nat.lt_of_lt_of_le","description":""},{"name":"Nat.lt_of_lt_of_eq","description":""},{"name":"Nat.instTransNatLtInstLTNat","description":""},{"name":"Nat.instTransNatLeInstLENat","description":""},{"name":"Nat.instTransNatLtInstLTNatLeInstLENat","description":""},{"name":"Nat.instTransNatLeInstLENatLtInstLTNat","description":""},{"name":"Nat.le_of_eq","description":""},{"name":"Nat.le_of_succ_le","description":""},{"name":"Nat.le_of_lt","description":""},{"name":"Nat.lt.step","description":""},{"name":"Nat.eq_zero_or_pos","description":""},{"name":"Nat.lt.base","description":""},{"name":"Nat.lt_succ_self","description":""},{"name":"Nat.le_total","description":""},{"name":"Nat.lt_of_le_and_ne","description":""},{"name":"Nat.eq_zero_of_le_zero","description":""},{"name":"Nat.lt_of_succ_lt","description":""},{"name":"Nat.lt_of_succ_lt_succ","description":""},{"name":"Nat.lt_of_succ_le","description":""},{"name":"Nat.succ_le_of_lt","description":""},{"name":"Nat.zero_lt_of_lt","description":""},{"name":"Nat.le_or_eq_or_le_succ","description":""},{"name":"Nat.le_add_right","description":""},{"name":"Nat.le_add_left","description":""},{"name":"Nat.le.dest","description":""},{"name":"Nat.le.intro","description":""},{"name":"Nat.not_le_of_gt","description":""},{"name":"Nat.gt_of_not_le","description":""},{"name":"Nat.ge_of_not_lt","description":""},{"name":"Nat.add_le_add_left","description":""},{"name":"Nat.add_le_add_right","description":""},{"name":"Nat.add_lt_add_left","description":""},{"name":"Nat.add_lt_add_right","description":""},{"name":"Nat.zero_lt_one","description":""},{"name":"Nat.add_le_add","description":""},{"name":"Nat.add_lt_add","description":""},{"name":"Nat.le_of_add_le_add_left","description":""},{"name":"Nat.le_of_add_le_add_right","description":""},{"name":"Nat.ctor_eq_zero","description":""},{"name":"Nat.one_ne_zero","description":""},{"name":"Nat.zero_ne_one","description":""},{"name":"Nat.succ_ne_zero","description":""},{"name":"Nat.mul_le_mul_left","description":""},{"name":"Nat.mul_le_mul_right","description":""},{"name":"Nat.mul_le_mul","description":""},{"name":"Nat.mul_lt_mul_of_pos_left","description":""},{"name":"Nat.mul_lt_mul_of_pos_right","description":""},{"name":"Nat.mul_pos","description":""},{"name":"Nat.le_of_mul_le_mul_left","description":""},{"name":"Nat.eq_of_mul_eq_mul_left","description":""},{"name":"Nat.eq_of_mul_eq_mul_right","description":""},{"name":"Nat.pow_succ","description":""},{"name":"Nat.pow_zero","description":""},{"name":"Nat.pow_le_pow_of_le_left","description":""},{"name":"Nat.pow_le_pow_of_le_right","description":""},{"name":"Nat.pos_pow_of_pos","description":""},{"name":"Nat.min","description":""},{"name":"Nat.max","description":""},{"name":"Nat.not_eq_zero_of_lt","description":""},{"name":"Nat.pred_lt'","description":""},{"name":"Nat.add_sub_self_left","description":""},{"name":"Nat.add_sub_self_right","description":""},{"name":"Nat.sub_le_succ_sub","description":""},{"name":"Nat.zero_lt_sub_of_lt","description":""},{"name":"Nat.sub_succ_lt_self","description":""},{"name":"Nat.succ_pred","description":""},{"name":"Nat.sub_ne_zero_of_lt","description":""},{"name":"Nat.add_sub_of_le","description":""},{"name":"Nat.sub_add_cancel","description":""},{"name":"Nat.add_sub_add_right","description":""},{"name":"Nat.add_sub_add_left","description":""},{"name":"Nat.add_sub_cancel","description":""},{"name":"Nat.add_sub_cancel_left","description":""},{"name":"Nat.add_sub_assoc","description":""},{"name":"Nat.eq_add_of_sub_eq","description":""},{"name":"Nat.sub_eq_of_eq_add","description":""},{"name":"Nat.le_add_of_sub_le","description":""},{"name":"Nat.zero_sub","description":""},{"name":"Nat.sub_self_add","description":""},{"name":"Nat.sub_eq_zero_of_le","description":""},{"name":"Nat.sub_le_of_le_add","description":""},{"name":"Nat.add_le_of_le_sub","description":""},{"name":"Nat.le_sub_of_add_le","description":""},{"name":"Nat.pred_zero","description":""},{"name":"Nat.pred_succ","description":""},{"name":"Nat.sub.elim","description":""},{"name":"Nat.mul_pred_left","description":""},{"name":"Nat.mul_pred_right","description":""},{"name":"Nat.sub_sub","description":""},{"name":"Nat.mul_sub_right_distrib","description":""},{"name":"Nat.mul_sub_left_distrib","description":""},{"name":"Nat.not_le_eq","description":""},{"name":"Nat.not_ge_eq","description":""},{"name":"Nat.not_lt_eq","description":""},{"name":"Nat.not_gt_eq","description":""},{"name":"Prod.foldI","description":""},{"name":"Prod.anyI","description":""},{"name":"Prod.allI","description":""},{"name":"System.Platform.getIsWindows","description":""},{"name":"System.Platform.getIsOSX","description":""},{"name":"System.Platform.getIsEmscripten","description":""},{"name":"System.Platform.isWindows","description":""},{"name":"System.Platform.isOSX","description":""},{"name":"System.Platform.isEmscripten","description":""},{"name":"bfix1","description":""},{"name":"fixCore1","description":""},{"name":"fixCore","description":""},{"name":"fix1","description":""},{"name":"fix","description":""},{"name":"bfix2","description":""},{"name":"fixCore2","description":""},{"name":"fix2","description":""},{"name":"bfix3","description":""},{"name":"fixCore3","description":""},{"name":"fix3","description":""},{"name":"bfix4","description":""},{"name":"fixCore4","description":""},{"name":"fix4","description":""},{"name":"bfix5","description":""},{"name":"fixCore5","description":""},{"name":"fix5","description":""},{"name":"bfix6","description":""},{"name":"fixCore6","description":""},{"name":"fix6","description":""},{"name":"Option.eq_of_eq_some","description":""},{"name":"Option.eq_none_of_isNone","description":""},{"name":"IO.RealWorld","description":"Like https://hackage.haskell.org/package/ghc-Prim-0.5.2.0/docs/GHC-Prim.html#t:RealWorld.\n    Makes sure we never reorder `IO` operations.\n\n    TODO: mark opaque "},{"name":"EIO","description":""},{"name":"instMonadEIO","description":""},{"name":"instMonadFinallyEIO","description":""},{"name":"instMonadExceptOfEIO","description":""},{"name":"instOrElseEIO","description":""},{"name":"instInhabitedEIO","description":""},{"name":"BaseIO","description":"An `EIO` monad that cannot throw exceptions. "},{"name":"instMonadBaseIO","description":""},{"name":"instMonadFinallyBaseIO","description":""},{"name":"BaseIO.toEIO","description":""},{"name":"instMonadLiftBaseIOEIO","description":""},{"name":"EIO.toBaseIO","description":""},{"name":"EIO.catchExceptions","description":""},{"name":"IO","description":""},{"name":"BaseIO.toIO","description":""},{"name":"EIO.toIO","description":""},{"name":"EIO.toIO'","description":""},{"name":"IO.toEIO","description":""},{"name":"unsafeBaseIO","description":""},{"name":"unsafeEIO","description":""},{"name":"unsafeIO","description":""},{"name":"timeit","description":""},{"name":"allocprof","description":""},{"name":"IO.initializing","description":""},{"name":"BaseIO.asTask","description":"Run `act` in a separate `Task`.\n  This is similar to Haskell's [`unsafeInterleaveIO`](http://hackage.haskell.org/package/base-4.14.0.0/docs/System-IO-Unsafe.html#v:unsafeInterleaveIO),\n  except that the `Task` is started eagerly as usual. Thus pure accesses to the `Task` do not influence the impure `act`\n  computation.\n  Unlike with pure tasks created by `Task.spawn`, tasks created by this function will be run even if the last reference\n  to the task is dropped. The `act` should manually check for cancellation via `IO.checkCanceled` if it wants to react\n  to that. "},{"name":"BaseIO.mapTask","description":"See `BaseIO.asTask`. "},{"name":"BaseIO.bindTask","description":"See `BaseIO.asTask`. "},{"name":"BaseIO.mapTasks","description":""},{"name":"BaseIO.mapTasks.go","description":""},{"name":"EIO.asTask","description":"`EIO` specialization of `BaseIO.asTask`. "},{"name":"EIO.mapTask","description":"`EIO` specialization of `BaseIO.mapTask`. "},{"name":"EIO.bindTask","description":"`EIO` specialization of `BaseIO.bindTask`. "},{"name":"EIO.mapTasks","description":"`EIO` specialization of `BaseIO.mapTasks`. "},{"name":"IO.ofExcept","description":""},{"name":"IO.lazyPure","description":""},{"name":"IO.monoMsNow","description":"Monotonically increasing time since an unspecified past point in milliseconds. No relation to wall clock time. "},{"name":"IO.getRandomBytes","description":"Read bytes from a system entropy source. Not guaranteed to be cryptographically secure.\nIf `nBytes = 0`, return immediately with an empty buffer. "},{"name":"IO.sleep","description":""},{"name":"IO.asTask","description":"`IO` specialization of `EIO.asTask`. "},{"name":"IO.mapTask","description":"`IO` specialization of `EIO.mapTask`. "},{"name":"IO.bindTask","description":"`IO` specialization of `EIO.bindTask`. "},{"name":"IO.mapTasks","description":"`IO` specialization of `EIO.mapTasks`. "},{"name":"IO.checkCanceled","description":"Check if the task's cancellation flag has been set by calling `IO.cancel` or dropping the last reference to the task. "},{"name":"IO.cancel","description":"Request cooperative cancellation of the task. The task must explicitly call `IO.checkCanceled` to react to the cancellation. "},{"name":"IO.hasFinished","description":"Check if the task has finished execution, at which point calling `Task.get` will return immediately. "},{"name":"IO.wait","description":"Wait for the task to finish, then return its result. "},{"name":"IO.waitAny","description":"Wait until any of the tasks in the given list has finished, then return its result. "},{"name":"IO.getNumHeartbeats","description":"Helper method for implementing \"deterministic\" timeouts. It is the number of \"small\" memory allocations performed by the current execution thread. "},{"name":"IO.FS.Mode","description":""},{"name":"IO.FS.Handle","description":""},{"name":"IO.FS.Stream","description":"A pure-Lean abstraction of POSIX streams. We use `Stream`s for the standard streams stdin/stdout/stderr so we can\n  capture output of `#eval` commands into memory. "},{"name":"IO.FS.instInhabitedStream","description":""},{"name":"IO.getStdin","description":""},{"name":"IO.getStdout","description":""},{"name":"IO.getStderr","description":""},{"name":"IO.setStdin","description":"Replaces the stdin stream of the current thread and returns its previous value. "},{"name":"IO.setStdout","description":"Replaces the stdout stream of the current thread and returns its previous value. "},{"name":"IO.setStderr","description":"Replaces the stderr stream of the current thread and returns its previous value. "},{"name":"IO.iterate","description":""},{"name":"IO.FS.Handle.mkPrim","description":""},{"name":"IO.FS.Handle.mk","description":""},{"name":"IO.FS.Handle.isEof","description":"Returns whether the end of the file has been reached while reading a file.\n`h.isEof` returns true /after/ the first attempt at reading past the end of `h`.\nOnce `h.isEof` is true, reading `h` will always return an empty array.\n"},{"name":"IO.FS.Handle.flush","description":""},{"name":"IO.FS.Handle.read","description":""},{"name":"IO.FS.Handle.write","description":""},{"name":"IO.FS.Handle.getLine","description":""},{"name":"IO.FS.Handle.putStr","description":""},{"name":"IO.FS.realPath","description":""},{"name":"IO.FS.removeFile","description":""},{"name":"IO.FS.removeDir","description":"Remove given directory. Fails if not empty; see also `IO.FS.removeDirAll`. "},{"name":"IO.FS.createDir","description":""},{"name":"IO.getEnv","description":""},{"name":"IO.appPath","description":""},{"name":"IO.currentDir","description":""},{"name":"IO.FS.withFile","description":""},{"name":"IO.FS.Handle.putStrLn","description":""},{"name":"IO.FS.Handle.readBinToEnd","description":""},{"name":"IO.FS.Handle.readBinToEnd.loop","description":""},{"name":"IO.FS.Handle.readToEnd","description":""},{"name":"IO.FS.Handle.readToEnd.loop","description":""},{"name":"IO.FS.readBinFile","description":""},{"name":"IO.FS.readFile","description":""},{"name":"IO.FS.lines","description":""},{"name":"IO.FS.lines.read","description":""},{"name":"IO.FS.writeBinFile","description":""},{"name":"IO.FS.writeFile","description":""},{"name":"IO.FS.Stream.putStrLn","description":""},{"name":"IO.FS.DirEntry","description":""},{"name":"IO.FS.instReprDirEntry","description":""},{"name":"IO.FS.DirEntry.path","description":""},{"name":"IO.FS.FileType","description":""},{"name":"IO.FS.instReprFileType","description":""},{"name":"IO.FS.instBEqFileType","description":""},{"name":"IO.FS.SystemTime","description":""},{"name":"IO.FS.instReprSystemTime","description":""},{"name":"IO.FS.instBEqSystemTime","description":""},{"name":"IO.FS.instOrdSystemTime","description":""},{"name":"IO.FS.instInhabitedSystemTime","description":""},{"name":"IO.FS.instLTSystemTime","description":""},{"name":"IO.FS.instLESystemTime","description":""},{"name":"IO.FS.Metadata","description":""},{"name":"IO.FS.instReprMetadata","description":""},{"name":"System.FilePath.readDir","description":""},{"name":"System.FilePath.metadata","description":""},{"name":"System.FilePath.isDir","description":""},{"name":"System.FilePath.pathExists","description":""},{"name":"System.FilePath.walkDir","description":"Return all filesystem entries of a preorder traversal of all directories satisfying `enter`, starting at `p`.\n  Symbolic links are visited as well by default. "},{"name":"System.FilePath.walkDir.go","description":""},{"name":"IO.withStdin","description":""},{"name":"IO.withStdout","description":""},{"name":"IO.withStderr","description":""},{"name":"IO.print","description":""},{"name":"IO.println","description":""},{"name":"IO.eprint","description":""},{"name":"IO.eprintln","description":""},{"name":"IO.appDir","description":""},{"name":"IO.FS.createDirAll","description":"Create given path and all missing parents as directories. "},{"name":"IO.FS.removeDirAll","description":"Fully remove given directory by deleting all contained files and directories in an unspecified order.\n  Fails if any contained entry cannot be deleted or was newly created during execution. "},{"name":"IO.Process.Stdio","description":""},{"name":"IO.Process.Stdio.toHandleType","description":""},{"name":"IO.Process.StdioConfig","description":""},{"name":"IO.Process.SpawnArgs","description":""},{"name":"IO.Process.Child","description":""},{"name":"IO.Process.spawn","description":""},{"name":"IO.Process.Child.wait","description":""},{"name":"IO.Process.Child.takeStdin","description":"Extract the `stdin` field from a `Child` object, allowing them to be freed independently.\nThis operation is necessary for closing the child process' stdin while still holding on to a process handle,\ne.g. for `Child.wait`. A file handle is closed when all references to it are dropped, which without this\noperation includes the `Child` object.\n"},{"name":"IO.Process.Output","description":""},{"name":"IO.Process.output","description":"Run process to completion and capture output. "},{"name":"IO.Process.run","description":"Run process to completion and return stdout on success. "},{"name":"IO.Process.exit","description":""},{"name":"IO.AccessRight","description":""},{"name":"IO.AccessRight.flags","description":""},{"name":"IO.FileRight","description":""},{"name":"IO.FileRight.flags","description":""},{"name":"IO.Prim.setAccessRights","description":""},{"name":"IO.setAccessRights","description":""},{"name":"IO.Ref","description":""},{"name":"IO.instMonadLiftSTRealWorldBaseIO","description":""},{"name":"IO.mkRef","description":""},{"name":"IO.FS.Stream.ofHandle","description":""},{"name":"IO.FS.Stream.Buffer","description":""},{"name":"IO.FS.Stream.ofBuffer","description":""},{"name":"IO.FS.withIsolatedStreams","description":"Run action with `stdin` emptied and `stdout+stderr` captured into a `String`. "},{"name":"Lean.Eval","description":"Typeclass used for presenting the output of an `#eval` command. "},{"name":"Lean.instEval","description":""},{"name":"Lean.instEval_1","description":""},{"name":"Lean.instEvalUnit","description":""},{"name":"Lean.instEvalIO","description":""},{"name":"Lean.runEval","description":""},{"name":"termPrintln!__","description":""},{"name":"IO.Error","description":""},{"name":"IO.instInhabitedError","description":""},{"name":"IO.userError","description":""},{"name":"instCoeStringError","description":""},{"name":"IO.Error.mkAlreadyExistsFile","description":""},{"name":"IO.Error.mkEofError","description":""},{"name":"IO.Error.mkInappropriateTypeFile","description":""},{"name":"IO.Error.mkInterrupted","description":""},{"name":"IO.Error.mkInvalidArgumentFile","description":""},{"name":"IO.Error.mkNoFileOrDirectory","description":""},{"name":"IO.Error.mkNoSuchThingFile","description":""},{"name":"IO.Error.mkPermissionDeniedFile","description":""},{"name":"IO.Error.mkResourceExhaustedFile","description":""},{"name":"IO.Error.mkUnsupportedOperation","description":""},{"name":"IO.Error.mkResourceExhausted","description":""},{"name":"IO.Error.mkAlreadyExists","description":""},{"name":"IO.Error.mkInappropriateType","description":""},{"name":"IO.Error.mkNoSuchThing","description":""},{"name":"IO.Error.mkResourceVanished","description":""},{"name":"IO.Error.mkResourceBusy","description":""},{"name":"IO.Error.mkInvalidArgument","description":""},{"name":"IO.Error.mkOtherError","description":""},{"name":"IO.Error.mkPermissionDenied","description":""},{"name":"IO.Error.mkHardwareFault","description":""},{"name":"IO.Error.mkUnsatisfiedConstraints","description":""},{"name":"IO.Error.mkIllegalOperation","description":""},{"name":"IO.Error.mkProtocolError","description":""},{"name":"IO.Error.mkTimeExpired","description":""},{"name":"IO.Error.fopenErrorToString","description":""},{"name":"IO.Error.otherErrorToString","description":""},{"name":"IO.Error.toString","description":""},{"name":"IO.Error.instToStringError","description":""},{"name":"eq_self","description":""},{"name":"of_eq_true","description":""},{"name":"eq_true","description":""},{"name":"eq_false","description":""},{"name":"eq_false'","description":""},{"name":"eq_true_of_decide","description":""},{"name":"eq_false_of_decide","description":""},{"name":"implies_congr","description":""},{"name":"implies_congr_ctx","description":""},{"name":"implies_dep_congr_ctx","description":""},{"name":"forall_congr","description":""},{"name":"let_congr","description":""},{"name":"let_val_congr","description":""},{"name":"let_body_congr","description":""},{"name":"ite_congr","description":""},{"name":"Eq.mpr_prop","description":""},{"name":"Eq.mpr_not","description":""},{"name":"dite_congr","description":""},{"name":"ne_eq","description":""},{"name":"ite_true","description":""},{"name":"ite_false","description":""},{"name":"dite_true","description":""},{"name":"dite_false","description":""},{"name":"and_self","description":""},{"name":"and_true","description":""},{"name":"true_and","description":""},{"name":"and_false","description":""},{"name":"false_and","description":""},{"name":"or_self","description":""},{"name":"or_true","description":""},{"name":"true_or","description":""},{"name":"or_false","description":""},{"name":"false_or","description":""},{"name":"iff_self","description":""},{"name":"iff_true","description":""},{"name":"true_iff","description":""},{"name":"iff_false","description":""},{"name":"false_iff","description":""},{"name":"false_implies","description":""},{"name":"implies_true","description":""},{"name":"true_implies","description":""},{"name":"Bool.or_false","description":""},{"name":"Bool.or_true","description":""},{"name":"Bool.false_or","description":""},{"name":"Bool.true_or","description":""},{"name":"Bool.or_self","description":""},{"name":"Bool.or_eq_true","description":""},{"name":"Bool.and_false","description":""},{"name":"Bool.and_true","description":""},{"name":"Bool.false_and","description":""},{"name":"Bool.true_and","description":""},{"name":"Bool.and_self","description":""},{"name":"Bool.and_eq_true","description":""},{"name":"Bool.not_not","description":""},{"name":"Bool.not_true","description":""},{"name":"Bool.not_false","description":""},{"name":"Bool.not_beq_true","description":""},{"name":"Bool.not_beq_false","description":""},{"name":"Bool.beq_to_eq","description":""},{"name":"Bool.not_beq_to_not_eq","description":""},{"name":"Bool.not_eq_true","description":""},{"name":"Bool.not_eq_false","description":""},{"name":"decide_eq_true_eq","description":""},{"name":"decide_not","description":""},{"name":"not_decide_eq_true","description":""},{"name":"heq_eq_eq","description":""},{"name":"cond_true","description":""},{"name":"cond_false","description":""},{"name":"beq_self_eq_true","description":""},{"name":"Socket.Socket.Nonempty","description":"Use `NonemptyType` to implement `Inhabited` for `Socket`.\n  [detailed explanation](#explanation-usage-of-nonemptytype)\n"},{"name":"Socket.Socket","description":"Opaque reference to underlying platform specific socket.\n\n  To create a `Socket`, refer to [`Socket.mk`](##Socket.Socket.mk). Then you\n  can manipulate the `Socket` using common socket functions like\n  [`Socket.bind`](##Socket.Socket.bind),[`Socket.connect`](##Socket.Socket.connect),\n  etc. For all functions available, refer to the [`Socket` module](Socket/Socket.html).\n\n  *NOTE*: `NonemptyType` is used to implement `Inhabited` for `Socket`. [detailed explanation](#explanation-usage-of-nonemptytype)\n\n  ```lean\n  import Socket\n  open Socket\n\n  def main : IO Unit := do\n    let s ← Socket.mk\n    -- some socket operations\n    s.close\n  ```\n"},{"name":"Socket.instNonemptySocket","description":"Use `NonemptyType` to implement `Inhabited` for `Socket`.\n  [detailed explanation](#explanation-usage-of-nonemptytype)\n"},{"name":"Socket.SockAddr.Nonempty","description":"Use `NonemptyType` to implement `Inhabited` for `SockAddr`.\n  [detailed explanation](#explanation-usage-of-nonemptytype)\n"},{"name":"Socket.SockAddr","description":"Opaque reference to underlying socket address.\n\n  *NOTE*: Different from the C `sockaddr`, `SockAddr` also includes length.\n"},{"name":"Socket.instNonemptySockAddr","description":"Use `NonemptyType` to implement `Inhabited` for `SockAddr`\n  [detailed explanation](#explanation-usage-of-nonemptytype)\n"},{"name":"Socket.AddressFamily","description":"Enumeration of supported address families,\n  which is used in [`Socket.mk`](/find/Socket.Socket.mk).\n"},{"name":"Socket.instInhabitedAddressFamily","description":""},{"name":"Socket.instToStringAddressFamily","description":"Convert `AddressFamily` to `String`. "},{"name":"Socket.SockType","description":"Enumeration of supported socket types,\n  which is used in [`Socket.mk`](/find/Socket.Socket.mk).\n"},{"name":"Socket.instInhabitedSockType","description":""},{"name":"Socket.instToStringSockType","description":"Convert `SockType` to `String`. "},{"name":"Socket.ShutdownHow","description":"Enumeration of how is socket shutdown,\n  which is used in [`Socket.shutdown`](##Socket.Socket.shutdown).\n"},{"name":"Socket.instInhabitedShutdownHow","description":""},{"name":"Socket.hostname","description":"Get hostname of current machine. "},{"name":"Classical.indefiniteDescription","description":""},{"name":"Classical.choose","description":""},{"name":"Classical.choose_spec","description":""},{"name":"Classical.em","description":""},{"name":"Classical.exists_true_of_nonempty","description":""},{"name":"Classical.inhabited_of_nonempty","description":""},{"name":"Classical.inhabited_of_exists","description":""},{"name":"Classical.propDecidable","description":""},{"name":"Classical.decidableInhabited","description":""},{"name":"Classical.typeDecidableEq","description":""},{"name":"Classical.typeDecidable","description":""},{"name":"Classical.strongIndefiniteDescription","description":""},{"name":"Classical.epsilon","description":""},{"name":"Classical.epsilon_spec_aux","description":""},{"name":"Classical.epsilon_spec","description":""},{"name":"Classical.epsilon_singleton","description":""},{"name":"Classical.axiomOfChoice","description":""},{"name":"Classical.skolem","description":""},{"name":"Classical.propComplete","description":""},{"name":"Classical.byCases","description":""},{"name":"Classical.byContradiction","description":""},{"name":"Classical.«tacticBy_cases__:_»","description":""},{"name":"List.mapM","description":""},{"name":"List.mapA","description":""},{"name":"List.forM","description":""},{"name":"List.forA","description":""},{"name":"List.filterAuxM","description":""},{"name":"List.filterM","description":""},{"name":"List.filterRevM","description":""},{"name":"List.filterMapM","description":""},{"name":"List.filterMapM.loop","description":""},{"name":"List.foldlM","description":""},{"name":"List.foldrM","description":""},{"name":"List.firstM","description":""},{"name":"List.anyM","description":""},{"name":"List.allM","description":""},{"name":"List.findM?","description":""},{"name":"List.findSomeM?","description":""},{"name":"List.forIn","description":""},{"name":"List.forIn.loop","description":""},{"name":"List.instForInList","description":""},{"name":"List.forIn_nil","description":""},{"name":"List.forIn_cons","description":""},{"name":"List.instForMList","description":""},{"name":"List.forM_nil","description":""},{"name":"List.forM_cons","description":""},{"name":"List.get!","description":""},{"name":"List.get?","description":""},{"name":"List.getD","description":""},{"name":"List.head!","description":""},{"name":"List.head?","description":""},{"name":"List.headD","description":""},{"name":"List.head","description":""},{"name":"List.tail!","description":""},{"name":"List.tail?","description":""},{"name":"List.tailD","description":""},{"name":"List.getLast","description":""},{"name":"List.getLast!","description":""},{"name":"List.getLast?","description":""},{"name":"List.getLastD","description":""},{"name":"List.rotateLeft","description":""},{"name":"List.rotateRight","description":""},{"name":"List.get_append_left","description":""},{"name":"List.get_append_right","description":""},{"name":"List.get_last","description":""},{"name":"Functor.mapRev","description":""},{"name":"«term_<&>_»","description":""},{"name":"Functor.discard","description":""},{"name":"Alternative","description":""},{"name":"instOrElse","description":""},{"name":"guard","description":""},{"name":"optional","description":""},{"name":"ToBool","description":""},{"name":"instToBoolBool","description":""},{"name":"bool","description":""},{"name":"orM","description":""},{"name":"«term_<||>_»","description":""},{"name":"andM","description":""},{"name":"«term_<&&>_»","description":""},{"name":"notM","description":""},{"name":"MonadControl","description":""},{"name":"MonadControlT","description":""},{"name":"instMonadControlT","description":""},{"name":"instMonadControlT_1","description":""},{"name":"controlAt","description":""},{"name":"control","description":""},{"name":"ForM","description":""},{"name":"System.FilePath","description":""},{"name":"System.instInhabitedFilePath","description":""},{"name":"System.instDecidableEqFilePath","description":""},{"name":"System.instHashableFilePath","description":""},{"name":"System.instReprFilePath","description":""},{"name":"System.instToStringFilePath","description":""},{"name":"System.FilePath.pathSeparator","description":"The character that separates directories. In the case where more than one character is possible, `pathSeparator` is the 'ideal' one. "},{"name":"System.FilePath.pathSeparators","description":"The list of all possible separators. "},{"name":"System.FilePath.extSeparator","description":"File extension character "},{"name":"System.FilePath.exeExtension","description":""},{"name":"System.FilePath.isCaseInsensitive","description":"Case-insensitive file system "},{"name":"System.FilePath.normalize","description":""},{"name":"System.FilePath.isAbsolute","description":""},{"name":"System.FilePath.isRelative","description":""},{"name":"System.FilePath.join","description":""},{"name":"System.FilePath.instDivFilePath","description":""},{"name":"System.FilePath.instHDivFilePathString","description":""},{"name":"System.FilePath.parent","description":""},{"name":"System.FilePath.fileName","description":""},{"name":"System.FilePath.fileStem","description":"Extracts the stem (non-extension) part of `p.fileName`. "},{"name":"System.FilePath.extension","description":""},{"name":"System.FilePath.withFileName","description":""},{"name":"System.FilePath.withExtension","description":""},{"name":"System.FilePath.components","description":""},{"name":"System.mkFilePath","description":""},{"name":"System.instCoeStringFilePath","description":""},{"name":"System.SearchPath","description":""},{"name":"System.SearchPath.separator","description":"The character that is used to separate the entries in the $PATH (or %PATH%) environment variable. "},{"name":"System.SearchPath.parse","description":""},{"name":"System.SearchPath.toString","description":""},{"name":"instToFormat","description":""},{"name":"List.format","description":""},{"name":"instToFormatList","description":""},{"name":"instToFormatArray","description":""},{"name":"Option.format","description":""},{"name":"instToFormatOption","description":""},{"name":"instToFormatProd","description":""},{"name":"String.toFormat","description":""},{"name":"Std.termF!_","description":""},{"name":"Nat.forM","description":""},{"name":"Nat.forM.loop","description":""},{"name":"Nat.forRevM","description":""},{"name":"Nat.forRevM.loop","description":""},{"name":"Nat.foldM","description":""},{"name":"Nat.foldM.loop","description":""},{"name":"Nat.foldRevM","description":""},{"name":"Nat.foldRevM.loop","description":""},{"name":"Nat.allM","description":""},{"name":"Nat.allM.loop","description":""},{"name":"Nat.anyM","description":""},{"name":"Nat.anyM.loop","description":""},{"name":"Array.eq_of_isEqvAux","description":""},{"name":"Array.eq_of_isEqv","description":""},{"name":"Array.isEqvAux_self","description":""},{"name":"Array.isEqv_self","description":""},{"name":"Array.instDecidableEqArray","description":""},{"name":"Array.qpartition","description":""},{"name":"Array.qpartition.loop","description":""},{"name":"Array.qsort","description":""},{"name":"Array.qsort.sort","description":""},{"name":"Ordering","description":""},{"name":"instInhabitedOrdering","description":""},{"name":"instBEqOrdering","description":""},{"name":"Ord","description":""},{"name":"compareOfLessAndEq","description":""},{"name":"instOrdNat","description":""},{"name":"instOrdInt","description":""},{"name":"instOrdBool","description":""},{"name":"instOrdString","description":""},{"name":"instOrdFin","description":""},{"name":"instOrdUInt8","description":""},{"name":"instOrdUInt16","description":""},{"name":"instOrdUInt32","description":""},{"name":"instOrdUInt64","description":""},{"name":"instOrdUSize","description":""},{"name":"instOrdChar","description":""},{"name":"ltOfOrd","description":""},{"name":"instDecidableRelLtLtOfOrd","description":""},{"name":"Ordering.isLE","description":""},{"name":"leOfOrd","description":""},{"name":"instDecidableRelLeLeOfOrd","description":""},{"name":"RandomGen","description":""},{"name":"StdGen","description":""},{"name":"instInhabitedStdGen","description":""},{"name":"stdRange","description":""},{"name":"instReprStdGen","description":""},{"name":"stdNext","description":""},{"name":"stdSplit","description":""},{"name":"instRandomGenStdGen","description":""},{"name":"mkStdGen","description":"Return a standard number generator. "},{"name":"randNat","description":"Generate a random natural number in the interval [lo, hi]. "},{"name":"randBool","description":"Generate a random Boolean. "},{"name":"IO.stdGenRef","description":""},{"name":"IO.setRandSeed","description":""},{"name":"IO.rand","description":""},{"name":"ExceptCpsT","description":""},{"name":"ExceptCpsT.run","description":""},{"name":"ExceptCpsT.runK","description":""},{"name":"ExceptCpsT.runCatch","description":""},{"name":"ExceptCpsT.instMonadExceptCpsT","description":""},{"name":"ExceptCpsT.instLawfulMonadExceptCpsTInstMonadExceptCpsT","description":""},{"name":"ExceptCpsT.instMonadExceptOfExceptCpsT","description":""},{"name":"ExceptCpsT.lift","description":""},{"name":"ExceptCpsT.instMonadLiftExceptCpsT","description":""},{"name":"ExceptCpsT.instInhabitedExceptCpsT","description":""},{"name":"ExceptCpsT.run_pure","description":""},{"name":"ExceptCpsT.run_lift","description":""},{"name":"ExceptCpsT.run_throw","description":""},{"name":"ExceptCpsT.run_bind_lift","description":""},{"name":"ExceptCpsT.run_bind_throw","description":""},{"name":"ExceptCpsT.runCatch_pure","description":""},{"name":"ExceptCpsT.runCatch_lift","description":""},{"name":"ExceptCpsT.runCatch_throw","description":""},{"name":"ExceptCpsT.runCatch_bind_lift","description":""},{"name":"ExceptCpsT.runCatch_bind_throw","description":""},{"name":"Option.toMonad","description":""},{"name":"Option.toBool","description":""},{"name":"Option.isSome","description":""},{"name":"Option.isNone","description":""},{"name":"Option.isEqSome","description":""},{"name":"Option.bind","description":""},{"name":"Option.map","description":""},{"name":"Option.mapM","description":""},{"name":"Option.map_id","description":""},{"name":"Option.instFunctorOption","description":""},{"name":"Option.filter","description":""},{"name":"Option.all","description":""},{"name":"Option.any","description":""},{"name":"Option.orElse","description":""},{"name":"Option.instOrElseOption","description":""},{"name":"Option.lt","description":""},{"name":"Option.instDecidableRelOptionLt","description":""},{"name":"instDecidableEqOption","description":""},{"name":"instBEqOption","description":""},{"name":"instLTOption","description":""},{"name":"ToString","description":""},{"name":"instToStringIdType","description":""},{"name":"instToStringId","description":""},{"name":"instToStringString","description":""},{"name":"instToStringSubstring","description":""},{"name":"instToStringIterator","description":""},{"name":"instToStringBool","description":""},{"name":"instToStringDecidable","description":""},{"name":"List.toStringAux","description":""},{"name":"List.toString","description":""},{"name":"instToStringList","description":""},{"name":"instToStringPUnit","description":""},{"name":"instToStringULift","description":""},{"name":"instToStringUnit","description":""},{"name":"instToStringNat","description":""},{"name":"instToStringInt","description":""},{"name":"instToStringChar","description":""},{"name":"instToStringFin","description":""},{"name":"instToStringUInt8","description":""},{"name":"instToStringUInt16","description":""},{"name":"instToStringUInt32","description":""},{"name":"instToStringUInt64","description":""},{"name":"instToStringUSize","description":""},{"name":"instToStringFormat","description":""},{"name":"addParenHeuristic","description":""},{"name":"instToStringOption","description":""},{"name":"instToStringSum","description":""},{"name":"instToStringProd","description":""},{"name":"instToStringSigma","description":""},{"name":"instToStringSubtype","description":""},{"name":"String.toInt?","description":""},{"name":"String.isInt","description":""},{"name":"String.toInt!","description":""},{"name":"instToStringExcept","description":""},{"name":"instReprExcept","description":""},{"name":"isValidChar","description":""},{"name":"Char.lt","description":""},{"name":"Char.le","description":""},{"name":"Char.instLTChar","description":""},{"name":"Char.instLEChar","description":""},{"name":"Char.instDecidableLtCharInstLTChar","description":""},{"name":"Char.instDecidableLeCharInstLEChar","description":""},{"name":"Char.isValidCharNat","description":""},{"name":"Char.isValidUInt32","description":""},{"name":"Char.isValidChar_of_isValidChar_Nat","description":""},{"name":"Char.isValidChar_zero","description":""},{"name":"Char.toNat","description":""},{"name":"Char.instInhabitedChar","description":""},{"name":"Char.isWhitespace","description":""},{"name":"Char.isUpper","description":""},{"name":"Char.isLower","description":""},{"name":"Char.isAlpha","description":""},{"name":"Char.isDigit","description":""},{"name":"Char.isAlphanum","description":""},{"name":"Char.toLower","description":""},{"name":"Char.toUpper","description":""},{"name":"Array.insertionSort","description":""},{"name":"Array.insertionSort.traverse","description":""},{"name":"Array.insertionSort.swapLoop","description":""},{"name":"FloatArray","description":""},{"name":"FloatArray.mkEmpty","description":""},{"name":"FloatArray.empty","description":""},{"name":"FloatArray.instInhabitedFloatArray","description":""},{"name":"FloatArray.instEmptyCollectionFloatArray","description":""},{"name":"FloatArray.push","description":""},{"name":"FloatArray.size","description":""},{"name":"FloatArray.uget","description":""},{"name":"FloatArray.get","description":""},{"name":"FloatArray.get!","description":""},{"name":"FloatArray.get?","description":""},{"name":"FloatArray.getOp","description":""},{"name":"FloatArray.uset","description":""},{"name":"FloatArray.set","description":""},{"name":"FloatArray.set!","description":""},{"name":"FloatArray.isEmpty","description":""},{"name":"FloatArray.toList","description":""},{"name":"FloatArray.toList.loop","description":""},{"name":"FloatArray.forInUnsafe","description":""},{"name":"FloatArray.forInUnsafe.loop","description":""},{"name":"FloatArray.forIn","description":""},{"name":"FloatArray.forIn.loop","description":""},{"name":"FloatArray.instForInFloatArrayFloat","description":""},{"name":"FloatArray.foldlMUnsafe","description":""},{"name":"FloatArray.foldlMUnsafe.fold","description":""},{"name":"FloatArray.foldlM","description":""},{"name":"FloatArray.foldlM.loop","description":""},{"name":"FloatArray.foldl","description":""},{"name":"List.toFloatArray","description":""},{"name":"List.toFloatArray.loop","description":""},{"name":"instToStringFloatArray","description":""},{"name":"Acc","description":""},{"name":"Acc.ndrec","description":""},{"name":"Acc.ndrecOn","description":""},{"name":"Acc.inv","description":""},{"name":"WellFounded","description":""},{"name":"WellFoundedRelation","description":""},{"name":"WellFounded.apply","description":""},{"name":"WellFounded.recursion","description":""},{"name":"WellFounded.induction","description":""},{"name":"WellFounded.fixF","description":""},{"name":"WellFounded.fixFEq","description":""},{"name":"WellFounded.fix","description":""},{"name":"WellFounded.fix_eq","description":""},{"name":"emptyWf","description":""},{"name":"Subrelation.accessible","description":""},{"name":"Subrelation.wf","description":""},{"name":"InvImage.accessible","description":""},{"name":"InvImage.wf","description":""},{"name":"invImage","description":""},{"name":"TC.accessible","description":""},{"name":"TC.wf","description":""},{"name":"Nat.lt_wfRel","description":""},{"name":"Measure","description":""},{"name":"measure","description":""},{"name":"SizeOfRef","description":""},{"name":"sizeOfWFRel","description":""},{"name":"instWellFoundedRelation","description":""},{"name":"Prod.Lex","description":""},{"name":"Prod.Lex.right'","description":""},{"name":"Prod.RProd","description":""},{"name":"Prod.lexAccessible","description":""},{"name":"Prod.lex","description":""},{"name":"Prod.instWellFoundedRelationProd","description":""},{"name":"Prod.RProdSubLex","description":""},{"name":"Prod.rprod","description":""},{"name":"PSigma.Lex","description":""},{"name":"PSigma.lexAccessible","description":""},{"name":"PSigma.lex","description":""},{"name":"PSigma.instWellFoundedRelationPSigma","description":""},{"name":"PSigma.lexNdep","description":""},{"name":"PSigma.lexNdepWf","description":""},{"name":"PSigma.RevLex","description":""},{"name":"PSigma.revLexAccessible","description":""},{"name":"PSigma.revLex","description":""},{"name":"PSigma.SkipLeft","description":""},{"name":"PSigma.skipLeft","description":""},{"name":"PSigma.mkSkipLeft","description":""},{"name":"Lean.Parser.Syntax.addPrec","description":""},{"name":"Lean.Parser.Syntax.subPrec","description":""},{"name":"Lean.Parser.Syntax.addPrio","description":""},{"name":"Lean.Parser.Syntax.subPrio","description":""},{"name":"precMax","description":""},{"name":"precArg","description":""},{"name":"precLead","description":""},{"name":"«prec(_)»","description":""},{"name":"precMin","description":""},{"name":"precMin1","description":""},{"name":"termMax_prec","description":""},{"name":"prioDefault","description":""},{"name":"prioLow","description":""},{"name":"prioMid","description":""},{"name":"prioHigh","description":""},{"name":"«prio(_)»","description":""},{"name":"«stx_+»","description":""},{"name":"«stx_*»","description":""},{"name":"stx_?","description":""},{"name":"«stx_<|>_»","description":""},{"name":"«stx_,*»","description":""},{"name":"«stx_,+»","description":""},{"name":"«stx_,*,?»","description":""},{"name":"«stx_,+,?»","description":""},{"name":"stx!_","description":""},{"name":"rawNatLit","description":""},{"name":"«term_∘_»","description":""},{"name":"«term_×_»","description":""},{"name":"«term_|||_»","description":""},{"name":"«term_^^^_»","description":""},{"name":"«term_&&&_»","description":""},{"name":"«term_+_»","description":""},{"name":"«term_-_»","description":""},{"name":"«term_*_»","description":""},{"name":"«term_/_»","description":""},{"name":"«term_%_»","description":""},{"name":"«term_<<<_»","description":""},{"name":"«term_>>>_»","description":""},{"name":"«term_^_»","description":""},{"name":"«term_++_»","description":""},{"name":"«term-_»","description":""},{"name":"«term~~~_»","description":""},{"name":"«term_<=_»","description":""},{"name":"«term_≤_»","description":""},{"name":"«term_<_»","description":""},{"name":"«term_>=_»","description":""},{"name":"«term_≥_»","description":""},{"name":"«term_>_»","description":""},{"name":"«term_=_»","description":""},{"name":"«term_==_»","description":""},{"name":"«term_/\\_»","description":""},{"name":"«term_∧_»","description":""},{"name":"«term_\\/_»","description":""},{"name":"«term_∨_»","description":""},{"name":"«term¬_»","description":""},{"name":"«term_&&_»","description":""},{"name":"«term_||_»","description":""},{"name":"term!_","description":""},{"name":"«term_::_»","description":""},{"name":"«term_<|>_»","description":""},{"name":"«term_>>_»","description":""},{"name":"«term_>>=_»","description":""},{"name":"«term_<*>_»","description":""},{"name":"«term_<*_»","description":""},{"name":"«term_*>_»","description":""},{"name":"«term_<$>_»","description":""},{"name":"termDepIfThenElse","description":""},{"name":"termIfThenElse","description":""},{"name":"«termIfLet_:=_Then_Else_»","description":""},{"name":"boolIfThenElse","description":""},{"name":"«term_<|_»","description":""},{"name":"«term_|>_»","description":""},{"name":"«term_$__»","description":""},{"name":"«term{__:_//_}»","description":""},{"name":"termWithout_expected_type_","description":""},{"name":"«term[_]»","description":""},{"name":"«term%[_|_]»","description":""},{"name":"Lean.term_Matches_","description":""},{"name":"Lean.termThis","description":"Special identifier introduced by \"anonymous\" `have : ...`, `suffices p ...` etc. "},{"name":"Lean.Parser.Tactic.intro","description":"Introduce one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must be a `let` or function type.\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses can be anonymized via `_`,\n  or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n"},{"name":"Lean.Parser.Tactic.intros","description":"`intros x...` behaves like `intro x...`, but then keeps introducing (anonymous) hypotheses until goal is not of a function type. "},{"name":"Lean.Parser.Tactic.rename","description":"`rename t => x` renames the most recent hypothesis whose type matches `t` (which may contain placeholders) to `x`,\nor fails if no such hypothesis could be found. "},{"name":"Lean.Parser.Tactic.revert","description":"`revert x...` is the inverse of `intro x...`: it moves the given hypotheses into the main goal's target type. "},{"name":"Lean.Parser.Tactic.clear","description":"`clear x...` removes the given hypotheses, or fails if there are remaining references to a hypothesis. "},{"name":"Lean.Parser.Tactic.subst","description":"`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis of type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead. "},{"name":"Lean.Parser.Tactic.assumption","description":"`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`. "},{"name":"Lean.Parser.Tactic.contradiction","description":"`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n```lean\nexample (h : False) : p := by contradiction  -- inductive type/family with no applicable constructors\nexample (h : none = some true) : p := by contradiction  -- injectivity of constructors\nexample (h : 2 + 2 = 3) : p := by contradiction  -- decidable false proposition\nexample (h : p) (h' : ¬ p) : q := by contradiction\nexample (x : Nat) (h : x ≠ x) : p := by contradiction\n```\n"},{"name":"Lean.Parser.Tactic.apply","description":"`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n"},{"name":"Lean.Parser.Tactic.exact","description":"`exact e` closes the main goal if its target type matches that of `e`.\n"},{"name":"Lean.Parser.Tactic.refine","description":"`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`) holes in `e` that are not solved\nby unification with the main goal's target type are converted into new goals, using the hole's name, if any, as the goal case name.\n"},{"name":"Lean.Parser.Tactic.refine'","description":"`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`) and implicit parameters are also converted into new goals. "},{"name":"Lean.Parser.Tactic.constructor","description":"If the main goal's target type is an inductive type, `constructor` solves it with the first matching constructor, or else fails. "},{"name":"Lean.Parser.Tactic.case","description":"`case tag => tac` focuses on the goal with case name `tag` and solves it using `tac`, or else fails.\n`case tag x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with inaccessible names to the given names. "},{"name":"Lean.Parser.Tactic.«tacticNext___=>_»","description":"`next => tac` focuses on the next goal solves it using `tac`, or else fails.\n`next x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with inaccessible names to the given names. "},{"name":"Lean.Parser.Tactic.allGoals","description":"`allGoals tac` runs `tac` on each goal, concatenating the resulting goals, if any. "},{"name":"Lean.Parser.Tactic.anyGoals","description":"`anyGoals tac` applies the tactic `tac` to every goal, and succeeds if at least one application succeeds.  "},{"name":"Lean.Parser.Tactic.focus","description":"`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred. "},{"name":"Lean.Parser.Tactic.skip","description":"`skip` does nothing. "},{"name":"Lean.Parser.Tactic.done","description":"`done` succeeds iff there are no remaining goals. "},{"name":"Lean.Parser.Tactic.traceState","description":""},{"name":"Lean.Parser.Tactic.traceMessage","description":""},{"name":"Lean.Parser.Tactic.failIfSuccess","description":""},{"name":"Lean.Parser.Tactic.paren","description":""},{"name":"Lean.Parser.Tactic.withReducible","description":""},{"name":"Lean.Parser.Tactic.withReducibleAndInstances","description":""},{"name":"Lean.Parser.Tactic.first","description":"`first | tac | ...` runs each `tac` until one succeeds, or else fails. "},{"name":"Lean.Parser.Tactic.rotateLeft","description":""},{"name":"Lean.Parser.Tactic.rotateRight","description":""},{"name":"Lean.Parser.Tactic.tacticTry_","description":"`try tac` runs `tac` and succeeds even if `tac` failed. "},{"name":"Lean.Parser.Tactic.«tactic_<;>_»","description":"`tac <;> tac'` runs `tac` on the main goal and `tac'` on each produced goal, concatenating all goals produced by `tac'`. "},{"name":"Lean.Parser.Tactic.tacticRfl","description":"`rfl` is a shorthand for `exact rfl`. "},{"name":"Lean.Parser.Tactic.tacticAdmit","description":"`admit` is a shorthand for `exact sorry`. "},{"name":"Lean.Parser.Tactic.tacticSorry","description":"The `sorry` tactic is a shorthand for `exact sorry`. "},{"name":"Lean.Parser.Tactic.tacticInfer_instance","description":""},{"name":"Lean.Parser.Tactic.config","description":"Optional configuration option for tactics "},{"name":"Lean.Parser.Tactic.locationWildcard","description":""},{"name":"Lean.Parser.Tactic.locationHyp","description":""},{"name":"Lean.Parser.Tactic.location","description":""},{"name":"Lean.Parser.Tactic.change","description":""},{"name":"Lean.Parser.Tactic.changeWith","description":""},{"name":"Lean.Parser.Tactic.rwRule","description":""},{"name":"Lean.Parser.Tactic.rwRuleSeq","description":""},{"name":"Lean.Parser.Tactic.rewriteSeq","description":""},{"name":"Lean.Parser.Tactic.rwSeq","description":""},{"name":"Lean.Parser.Tactic.rwWithRfl","description":""},{"name":"Lean.Parser.Tactic.expandRwSeq","description":""},{"name":"Lean.Parser.Tactic.injection","description":""},{"name":"Lean.Parser.Tactic.injections","description":""},{"name":"Lean.Parser.Tactic.discharger","description":""},{"name":"Lean.Parser.Tactic.simpPre","description":""},{"name":"Lean.Parser.Tactic.simpPost","description":""},{"name":"Lean.Parser.Tactic.simpLemma","description":""},{"name":"Lean.Parser.Tactic.simpErase","description":""},{"name":"Lean.Parser.Tactic.simpStar","description":""},{"name":"Lean.Parser.Tactic.simp","description":""},{"name":"Lean.Parser.Tactic.simpAll","description":""},{"name":"Lean.Parser.Tactic.delta","description":"Delta expand the given definition.\n  This is a low-level tactic, it will expose how recursive definitions have been compiled by Lean. "},{"name":"Lean.Parser.Tactic.unfold","description":"Unfold definition. For non-recursive definitions, this tactic is identical to `delta`.\n  For recursive definitions, it hides the encoding tricks used by the Lean frontend to convince the\n  kernel that the definition terminates. "},{"name":"Lean.Parser.Tactic.tacticRefine_lift_","description":""},{"name":"Lean.Parser.Tactic.tacticHave_","description":""},{"name":"Lean.Parser.Tactic.«tacticHave__:=_»","description":""},{"name":"Lean.Parser.Tactic.tacticSuffices_","description":""},{"name":"Lean.Parser.Tactic.tacticLet_","description":""},{"name":"Lean.Parser.Tactic.tacticShow_","description":""},{"name":"Lean.Parser.Tactic.letrec","description":""},{"name":"Lean.Parser.Tactic.tacticRefine_lift'_","description":""},{"name":"Lean.Parser.Tactic.tacticHave'_","description":""},{"name":"Lean.Parser.Tactic.«tacticHave'__:=_»","description":""},{"name":"Lean.Parser.Tactic.tacticLet'_","description":""},{"name":"Lean.Parser.Tactic.inductionAlt","description":""},{"name":"Lean.Parser.Tactic.inductionAlts","description":""},{"name":"Lean.Parser.Tactic.induction","description":""},{"name":"Lean.Parser.Tactic.generalizeArg","description":""},{"name":"Lean.Parser.Tactic.generalize","description":"`generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal with a fresh hypothesis `x`s.\nIf `h` is given, `h : e = x` is introduced as well. "},{"name":"Lean.Parser.Tactic.casesTarget","description":""},{"name":"Lean.Parser.Tactic.cases","description":""},{"name":"Lean.Parser.Tactic.existsIntro","description":""},{"name":"Lean.Parser.Tactic.renameI","description":"`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. "},{"name":"Lean.Parser.Tactic.tacticRepeat_","description":""},{"name":"Lean.Parser.Tactic.tacticTrivial","description":""},{"name":"Lean.Parser.Tactic.split","description":""},{"name":"Lean.Parser.Tactic.specialize","description":"The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.\nThe premises of this hypothesis, either universal quantifications or non-dependent implications,\nare instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`.\nThe tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.\n"},{"name":"Lean.Parser.Tactic.tacticUnhygienic_","description":""},{"name":"Lean.Parser.Tactic.fail","description":""},{"name":"Lean.Parser.Attr.simp","description":""},{"name":"«term‹_›»","description":""},{"name":"Lean.Syntax.formatStxAux","description":""},{"name":"Lean.Syntax.formatStx","description":""},{"name":"Lean.Syntax.instToFormatSyntax","description":""},{"name":"Lean.Syntax.instToStringSyntax","description":""},{"name":"EST","description":""},{"name":"ST","description":""},{"name":"instMonadEST","description":""},{"name":"instMonadExceptOfEST","description":""},{"name":"instInhabitedEST","description":""},{"name":"instMonadST","description":""},{"name":"STWorld","description":""},{"name":"instSTWorld","description":""},{"name":"instSTWorldEST","description":""},{"name":"runEST","description":""},{"name":"runST","description":""},{"name":"instMonadLiftSTEST","description":""},{"name":"ST.RefPointed","description":""},{"name":"ST.Ref","description":""},{"name":"ST.instNonemptyRef","description":""},{"name":"ST.Prim.mkRef","description":""},{"name":"ST.Prim.Ref.get","description":""},{"name":"ST.Prim.Ref.set","description":""},{"name":"ST.Prim.Ref.swap","description":""},{"name":"ST.Prim.Ref.take","description":""},{"name":"ST.Prim.Ref.ptrEq","description":""},{"name":"ST.Prim.Ref.modifyUnsafe","description":""},{"name":"ST.Prim.Ref.modifyGetUnsafe","description":""},{"name":"ST.Prim.Ref.modify","description":""},{"name":"ST.Prim.Ref.modifyGet","description":""},{"name":"ST.mkRef","description":""},{"name":"ST.Ref.get","description":""},{"name":"ST.Ref.set","description":""},{"name":"ST.Ref.swap","description":""},{"name":"ST.Ref.take","description":""},{"name":"ST.Ref.ptrEq","description":""},{"name":"ST.Ref.modify","description":""},{"name":"ST.Ref.modifyGet","description":""},{"name":"Nat.gcd","description":""},{"name":"Nat.gcd_zero_left","description":""},{"name":"Nat.gcd_succ","description":""},{"name":"Nat.gcd_one_left","description":""},{"name":"Nat.gcd_zero_right","description":""},{"name":"Nat.gcd_self","description":""},{"name":"inline","description":""},{"name":"flip","description":""},{"name":"Function.const_apply","description":""},{"name":"Function.comp_apply","description":""},{"name":"Thunk","description":"Thunks are \"lazy\" values that are evaluated when first accessed using `Thunk.get/map/bind`.\n  The value is then stored and not recomputed for all further accesses. "},{"name":"Thunk.pure","description":"Store a value in a thunk. Note that the value has already been computed, so there is no laziness. "},{"name":"Thunk.get","description":""},{"name":"Thunk.map","description":""},{"name":"Thunk.bind","description":""},{"name":"Iff","description":""},{"name":"«term_<->_»","description":""},{"name":"«term_↔_»","description":""},{"name":"Sum","description":""},{"name":"«term_⊕_»","description":""},{"name":"PSum","description":""},{"name":"«term_⊕'_»","description":""},{"name":"Sigma","description":""},{"name":"PSigma","description":""},{"name":"Exists","description":""},{"name":"ForInStep","description":""},{"name":"ForIn","description":""},{"name":"DoResultPRBC","description":""},{"name":"DoResultPR","description":""},{"name":"DoResultBC","description":""},{"name":"DoResultSBC","description":""},{"name":"HasEquiv","description":""},{"name":"«term_≈_»","description":""},{"name":"EmptyCollection","description":""},{"name":"«term{}»","description":""},{"name":"«term∅»","description":""},{"name":"Task","description":""},{"name":"instInhabitedTask","description":""},{"name":"Task.Priority","description":"Task priority. Tasks with higher priority will always be scheduled before ones with lower priority. "},{"name":"Task.Priority.default","description":""},{"name":"Task.Priority.max","description":""},{"name":"Task.Priority.dedicated","description":"Any priority higher than `Task.Priority.max` will result in the task being scheduled immediately on a dedicated thread.\n  This is particularly useful for long-running and/or I/O-bound tasks since Lean will by default allocate no more\n  non-dedicated workers than the number of cores to reduce context switches. "},{"name":"Task.spawn","description":""},{"name":"Task.map","description":""},{"name":"Task.bind","description":""},{"name":"NonScalar","description":""},{"name":"PNonScalar","description":""},{"name":"Nat.add_zero","description":""},{"name":"optParam_eq","description":""},{"name":"strictOr","description":""},{"name":"strictAnd","description":""},{"name":"bne","description":""},{"name":"«term_!=_»","description":""},{"name":"LawfulBEq","description":""},{"name":"eq_of_beq","description":""},{"name":"instLawfulBEqBoolInstBEqInstDecidableEqBool","description":""},{"name":"instLawfulBEqCharInstBEqInstDecidableEqChar","description":""},{"name":"instLawfulBEqStringInstBEqInstDecidableEqString","description":""},{"name":"implies","description":""},{"name":"implies.trans","description":""},{"name":"trivial","description":""},{"name":"mt","description":""},{"name":"not_false","description":""},{"name":"not_not_intro","description":""},{"name":"proofIrrel","description":""},{"name":"id.def","description":""},{"name":"Eq.mp","description":""},{"name":"Eq.mpr","description":""},{"name":"Eq.substr","description":""},{"name":"cast_eq","description":""},{"name":"Ne","description":""},{"name":"«term_≠_»","description":""},{"name":"Ne.intro","description":""},{"name":"Ne.elim","description":""},{"name":"Ne.irrefl","description":""},{"name":"Ne.symm","description":""},{"name":"false_of_ne","description":""},{"name":"ne_false_of_self","description":""},{"name":"ne_true_of_not","description":""},{"name":"true_ne_false","description":""},{"name":"Bool.of_not_eq_true","description":""},{"name":"Bool.of_not_eq_false","description":""},{"name":"ne_of_beq_false","description":""},{"name":"beq_false_of_ne","description":""},{"name":"HEq.ndrec","description":""},{"name":"HEq.ndrecOn","description":""},{"name":"HEq.elim","description":""},{"name":"HEq.subst","description":""},{"name":"HEq.symm","description":""},{"name":"heq_of_eq","description":""},{"name":"HEq.trans","description":""},{"name":"heq_of_heq_of_eq","description":""},{"name":"heq_of_eq_of_heq","description":""},{"name":"type_eq_of_heq","description":""},{"name":"eqRec_heq","description":""},{"name":"heq_of_eqRec_eq","description":""},{"name":"cast_heq","description":""},{"name":"iff_iff_implies_and_implies","description":""},{"name":"Iff.refl","description":""},{"name":"Iff.rfl","description":""},{"name":"Iff.trans","description":""},{"name":"Iff.symm","description":""},{"name":"Iff.comm","description":""},{"name":"Exists.elim","description":""},{"name":"decide_true_eq_true","description":""},{"name":"decide_false_eq_false","description":""},{"name":"toBoolUsing","description":"Similar to `decide`, but uses an explicit instance "},{"name":"toBoolUsing_eq_true","description":""},{"name":"ofBoolUsing_eq_true","description":""},{"name":"ofBoolUsing_eq_false","description":""},{"name":"instDecidableTrue","description":""},{"name":"instDecidableFalse","description":""},{"name":"Decidable.byCases","description":""},{"name":"Decidable.em","description":""},{"name":"Decidable.byContradiction","description":""},{"name":"Decidable.of_not_not","description":""},{"name":"Decidable.not_and_iff_or_not","description":""},{"name":"decidableOfDecidableOfIff","description":""},{"name":"decidableOfDecidableOfEq","description":""},{"name":"instDecidableForAll","description":""},{"name":"instDecidableIff","description":""},{"name":"if_pos","description":""},{"name":"if_neg","description":""},{"name":"dif_pos","description":""},{"name":"dif_neg","description":""},{"name":"dif_eq_if","description":""},{"name":"instDecidableIteProp","description":""},{"name":"instDecidableDitePropNot","description":""},{"name":"noConfusionTypeEnum","description":""},{"name":"noConfusionEnum","description":""},{"name":"instInhabitedProp","description":""},{"name":"instInhabitedTrue","description":""},{"name":"instInhabitedNonScalar","description":""},{"name":"instInhabitedPNonScalar","description":""},{"name":"instInhabitedForInStep","description":""},{"name":"nonempty_of_exists","description":""},{"name":"Subsingleton","description":""},{"name":"Subsingleton.elim","description":""},{"name":"Subsingleton.helim","description":""},{"name":"instSubsingleton","description":""},{"name":"instSubsingletonDecidable","description":""},{"name":"recSubsingleton","description":""},{"name":"Equivalence","description":""},{"name":"emptyRelation","description":""},{"name":"Subrelation","description":""},{"name":"InvImage","description":""},{"name":"TC","description":""},{"name":"Subtype.existsOfSubtype","description":""},{"name":"Subtype.eq","description":""},{"name":"Subtype.eta","description":""},{"name":"Subtype.instInhabitedSubtype","description":""},{"name":"Subtype.instDecidableEqSubtype","description":""},{"name":"Sum.inhabitedLeft","description":""},{"name":"Sum.inhabitedRight","description":""},{"name":"instDecidableEqSum","description":""},{"name":"instInhabitedProd","description":""},{"name":"instDecidableEqProd","description":""},{"name":"instBEqProd","description":""},{"name":"instLTProd","description":""},{"name":"prodHasDecidableLt","description":""},{"name":"Prod.lt_def","description":""},{"name":"Prod.ext","description":""},{"name":"Prod.map","description":""},{"name":"ex_of_PSigma","description":""},{"name":"PSigma.eta","description":""},{"name":"PUnit.subsingleton","description":""},{"name":"PUnit.eq_punit","description":""},{"name":"instSubsingletonPUnit","description":""},{"name":"instInhabitedPUnit","description":""},{"name":"instDecidableEqPUnit","description":""},{"name":"Setoid","description":""},{"name":"instHasEquiv","description":""},{"name":"Setoid.refl","description":""},{"name":"Setoid.symm","description":""},{"name":"Setoid.trans","description":""},{"name":"propext","description":""},{"name":"Eq.propIntro","description":""},{"name":"instDecidableEqProp","description":""},{"name":"Iff.subst","description":""},{"name":"Quot.sound","description":""},{"name":"Quot.liftBeta","description":""},{"name":"Quot.indBeta","description":""},{"name":"Quot.liftOn","description":""},{"name":"Quot.inductionOn","description":""},{"name":"Quot.exists_rep","description":""},{"name":"Quot.indep","description":""},{"name":"Quot.indepCoherent","description":""},{"name":"Quot.liftIndepPr1","description":""},{"name":"Quot.rec","description":""},{"name":"Quot.recOn","description":""},{"name":"Quot.recOnSubsingleton","description":""},{"name":"Quot.hrecOn","description":""},{"name":"Quotient","description":""},{"name":"Quotient.mk","description":""},{"name":"Quotient.mk'","description":""},{"name":"Quotient.sound","description":""},{"name":"Quotient.lift","description":""},{"name":"Quotient.ind","description":""},{"name":"Quotient.liftOn","description":""},{"name":"Quotient.inductionOn","description":""},{"name":"Quotient.exists_rep","description":""},{"name":"Quotient.rec","description":""},{"name":"Quotient.recOn","description":""},{"name":"Quotient.recOnSubsingleton","description":""},{"name":"Quotient.hrecOn","description":""},{"name":"Quotient.lift₂","description":""},{"name":"Quotient.liftOn₂","description":""},{"name":"Quotient.ind₂","description":""},{"name":"Quotient.inductionOn₂","description":""},{"name":"Quotient.inductionOn₃","description":""},{"name":"Quotient.exact","description":""},{"name":"Quotient.recOnSubsingleton₂","description":""},{"name":"instDecidableEqQuotient","description":""},{"name":"Function.Equiv","description":""},{"name":"Function.Equiv.refl","description":""},{"name":"Function.Equiv.symm","description":""},{"name":"Function.Equiv.trans","description":""},{"name":"Function.Equiv.isEquivalence","description":""},{"name":"funext","description":""},{"name":"instSubsingletonForAll","description":""},{"name":"Squash","description":""},{"name":"Squash.mk","description":""},{"name":"Squash.ind","description":""},{"name":"Squash.lift","description":""},{"name":"instSubsingletonSquash","description":""},{"name":"Lean.reduceBool","description":"When the kernel tries to reduce a term `Lean.reduceBool c`, it will invoke the Lean interpreter to evaluate `c`.\n  The kernel will not use the interpreter if `c` is not a constant.\n  This feature is useful for performing proofs by reflection.\n\n  Remark: the Lean frontend allows terms of the from `Lean.reduceBool t` where `t` is a term not containing\n  free variables. The frontend automatically declares a fresh auxiliary constant `c` and replaces the term with\n  `Lean.reduceBool c`. The main motivation is that the code for `t` will be pre-compiled.\n\n  Warning: by using this feature, the Lean compiler and interpreter become part of your trusted code base.\n  This is extra 30k lines of code. More importantly, you will probably not be able to check your developement using\n  external type checkers (e.g., Trepplein) that do not implement this feature.\n  Keep in mind that if you are using Lean as programming language, you are already trusting the Lean compiler and interpreter.\n  So, you are mainly losing the capability of type checking your developement using external checkers.\n\n  Recall that the compiler trusts the correctness of all `[implementedBy ...]` and `[extern ...]` annotations.\n  If an extern function is executed, then the trusted code base will also include the implementation of the associated\n  foreign function.\n"},{"name":"Lean.reduceNat","description":"Similar to `Lean.reduceBool` for closed `Nat` terms.\n\n  Remark: we do not have plans for supporting a generic `reduceValue {α} (a : α) : α := a`.\n  The main issue is that it is non-trivial to convert an arbitrary runtime object back into a Lean expression.\n  We believe `Lean.reduceBool` enables most interesting applications (e.g., proof by reflection). "},{"name":"Lean.ofReduceBool","description":""},{"name":"Lean.ofReduceNat","description":""},{"name":"ToStream","description":""},{"name":"Stream","description":""},{"name":"Stream.forIn","description":""},{"name":"Stream.forIn.visit","description":""},{"name":"instForIn","description":""},{"name":"instToStreamList","description":""},{"name":"instToStreamArraySubarray","description":""},{"name":"instToStreamSubarray","description":""},{"name":"instToStreamStringSubstring","description":""},{"name":"instToStreamRange","description":""},{"name":"instStreamProdProd","description":""},{"name":"instStreamList","description":""},{"name":"instStreamSubarray","description":""},{"name":"instStreamRangeNat","description":""},{"name":"instStreamSubstringChar","description":""},{"name":"tacticSimp_wf","description":""},{"name":"tacticDecreasing_tactic","description":""},{"name":"FloatSpec","description":""},{"name":"floatSpec","description":""},{"name":"Float","description":""},{"name":"instInhabitedFloat","description":""},{"name":"Float.add","description":""},{"name":"Float.sub","description":""},{"name":"Float.mul","description":""},{"name":"Float.div","description":""},{"name":"Float.neg","description":""},{"name":"Float.lt","description":""},{"name":"Float.le","description":""},{"name":"instAddFloat","description":""},{"name":"instSubFloat","description":""},{"name":"instMulFloat","description":""},{"name":"instDivFloat","description":""},{"name":"instNegFloat","description":""},{"name":"instLTFloat","description":""},{"name":"instLEFloat","description":""},{"name":"Float.beq","description":""},{"name":"instBEqFloat","description":""},{"name":"Float.decLt","description":""},{"name":"Float.decLe","description":""},{"name":"floatDecLt","description":""},{"name":"floatDecLe","description":""},{"name":"Float.toString","description":""},{"name":"Float.toUInt8","description":""},{"name":"Float.toUInt16","description":""},{"name":"Float.toUInt32","description":""},{"name":"Float.toUInt64","description":""},{"name":"Float.toUSize","description":""},{"name":"instToStringFloat","description":""},{"name":"instReprFloat","description":""},{"name":"instReprAtomFloat","description":""},{"name":"UInt64.toFloat","description":""},{"name":"Float.sin","description":""},{"name":"Float.cos","description":""},{"name":"Float.tan","description":""},{"name":"Float.asin","description":""},{"name":"Float.acos","description":""},{"name":"Float.atan","description":""},{"name":"Float.atan2","description":""},{"name":"Float.sinh","description":""},{"name":"Float.cosh","description":""},{"name":"Float.tanh","description":""},{"name":"Float.asinh","description":""},{"name":"Float.acosh","description":""},{"name":"Float.atanh","description":""},{"name":"Float.exp","description":""},{"name":"Float.exp2","description":""},{"name":"Float.log","description":""},{"name":"Float.log2","description":""},{"name":"Float.log10","description":""},{"name":"Float.pow","description":""},{"name":"Float.sqrt","description":""},{"name":"Float.cbrt","description":""},{"name":"instPowFloat","description":""},{"name":"Float.scaleB","description":"Efficiently computes `x * 2^i`.\n"},{"name":"Nat.div","description":""},{"name":"Nat.instDivNat","description":""},{"name":"Nat.div_eq","description":""},{"name":"Nat.div.inductionOn","description":""},{"name":"Nat.mod","description":""},{"name":"Nat.instModNat","description":""},{"name":"Nat.mod_eq","description":""},{"name":"Nat.mod.inductionOn","description":""},{"name":"Nat.mod_zero","description":""},{"name":"Nat.mod_eq_of_lt","description":""},{"name":"Nat.mod_eq_sub_mod","description":""},{"name":"Nat.mod_lt","description":""},{"name":"Nat.mod_le","description":""},{"name":"Nat.zero_mod","description":""},{"name":"Nat.mod_self","description":""},{"name":"Nat.mod_one","description":""},{"name":"Array.binSearchAux","description":""},{"name":"Array.binSearch","description":""},{"name":"Array.binSearchContains","description":""},{"name":"Array.binInsertM","description":""},{"name":"Array.binInsert","description":""},{"name":"instLawfulBEqProdInstBEqProd","description":""},{"name":"monadLift_self","description":""},{"name":"LawfulFunctor","description":""},{"name":"id_map'","description":""},{"name":"LawfulApplicative","description":""},{"name":"pure_id_seq","description":""},{"name":"LawfulMonad","description":""},{"name":"bind_pure","description":""},{"name":"map_eq_pure_bind","description":""},{"name":"seq_eq_bind_map","description":""},{"name":"bind_congr","description":""},{"name":"bind_pure_unit","description":""},{"name":"map_congr","description":""},{"name":"seq_eq_bind","description":""},{"name":"seqRight_eq_bind","description":""},{"name":"seqLeft_eq_bind","description":""},{"name":"Id.map_eq","description":""},{"name":"Id.bind_eq","description":""},{"name":"Id.pure_eq","description":""},{"name":"Id.instLawfulMonadIdInstMonadId","description":""},{"name":"ExceptT.ext","description":""},{"name":"ExceptT.run_pure","description":""},{"name":"ExceptT.run_lift","description":""},{"name":"ExceptT.run_throw","description":""},{"name":"ExceptT.run_bind_lift","description":""},{"name":"ExceptT.bind_throw","description":""},{"name":"ExceptT.run_bind","description":""},{"name":"ExceptT.lift_pure","description":""},{"name":"ExceptT.run_map","description":""},{"name":"ExceptT.seq_eq","description":""},{"name":"ExceptT.bind_pure_comp","description":""},{"name":"ExceptT.seqLeft_eq","description":""},{"name":"ExceptT.seqRight_eq","description":""},{"name":"ExceptT.instLawfulMonadExceptTInstMonadExceptT","description":""},{"name":"ReaderT.ext","description":""},{"name":"ReaderT.run_pure","description":""},{"name":"ReaderT.run_bind","description":""},{"name":"ReaderT.run_map","description":""},{"name":"ReaderT.run_monadLift","description":""},{"name":"ReaderT.run_monadMap","description":""},{"name":"ReaderT.run_read","description":""},{"name":"ReaderT.run_seq","description":""},{"name":"ReaderT.run_seqRight","description":""},{"name":"ReaderT.run_seqLeft","description":""},{"name":"ReaderT.instLawfulMonadReaderTInstMonadReaderT","description":""},{"name":"instLawfulMonadStateRefT'InstMonadStateRefT'","description":""},{"name":"StateT.ext","description":""},{"name":"StateT.run'_eq","description":""},{"name":"StateT.run_pure","description":""},{"name":"StateT.run_bind","description":""},{"name":"StateT.run_map","description":""},{"name":"StateT.run_get","description":""},{"name":"StateT.run_set","description":""},{"name":"StateT.run_modify","description":""},{"name":"StateT.run_modifyGet","description":""},{"name":"StateT.run_lift","description":""},{"name":"StateT.run_bind_lift","description":""},{"name":"StateT.run_monadLift","description":""},{"name":"StateT.run_monadMap","description":""},{"name":"StateT.run_seq","description":""},{"name":"StateT.run_seqRight","description":""},{"name":"StateT.run_seqLeft","description":""},{"name":"StateT.seqRight_eq","description":""},{"name":"StateT.seqLeft_eq","description":""},{"name":"StateT.instLawfulMonadStateTInstMonadStateT","description":""},{"name":"Nat.bitwise","description":""},{"name":"Nat.land","description":""},{"name":"Nat.lor","description":""},{"name":"Nat.xor","description":""},{"name":"Nat.shiftLeft","description":""},{"name":"Nat.shiftRight","description":""},{"name":"Nat.instAndOpNat","description":""},{"name":"Nat.instOrOpNat","description":""},{"name":"Nat.instXorNat","description":""},{"name":"Nat.instShiftLeftNat","description":""},{"name":"Nat.instShiftRightNat","description":""},{"name":"SizeOf","description":""},{"name":"default.sizeOf","description":""},{"name":"instSizeOf","description":""},{"name":"sizeOf_default","description":""},{"name":"instSizeOfNat","description":""},{"name":"sizeOf_nat","description":""},{"name":"Unit.sizeOf","description":""},{"name":"Bool.sizeOf_eq_one","description":""},{"name":"Lean.Name.sizeOf","description":""},{"name":"instSizeOfName","description":""},{"name":"OfScientific","description":""},{"name":"Float.ofBinaryScientific","description":"Computes `m * 2^e`. "},{"name":"instOfScientificFloat","description":""},{"name":"Float.ofNat","description":""},{"name":"Float.ofInt","description":""},{"name":"instOfNatFloat","description":""},{"name":"Nat.toFloat","description":""},{"name":"Lean.«termMacro.trace[__]_»","description":""},{"name":"Lean.binderIdent","description":""},{"name":"Lean.unbracketedExplicitBinders","description":""},{"name":"Lean.bracketedExplicitBinders","description":""},{"name":"Lean.explicitBinders","description":""},{"name":"Lean.expandExplicitBindersAux","description":""},{"name":"Lean.expandExplicitBindersAux.loop","description":""},{"name":"Lean.expandBrackedBindersAux","description":""},{"name":"Lean.expandBrackedBindersAux.loop","description":""},{"name":"Lean.expandExplicitBinders","description":""},{"name":"Lean.expandBrackedBinders","description":""},{"name":"Lean.unifConstraint","description":""},{"name":"Lean.unifConstraintElem","description":""},{"name":"Lean.«command_Unif_hint___Where_|-⊢_»","description":""},{"name":"«term∃_,_»","description":""},{"name":"«termExists_,_»","description":""},{"name":"«termΣ_,_»","description":""},{"name":"«termΣ'_,_»","description":""},{"name":"«term_×__1»","description":""},{"name":"«term_×'_»","description":""},{"name":"calcStep","description":""},{"name":"calc","description":""},{"name":"tacticCalc_","description":""},{"name":"unexpandUnit","description":""},{"name":"unexpandListNil","description":""},{"name":"unexpandListCons","description":""},{"name":"unexpandListToArray","description":""},{"name":"unexpandProdMk","description":""},{"name":"unexpandIte","description":""},{"name":"unexpandSorryAx","description":""},{"name":"unexpandEqNDRec","description":""},{"name":"unexpandEqRec","description":""},{"name":"unexpandExists","description":""},{"name":"unexpandSigma","description":""},{"name":"unexpandPSigma","description":""},{"name":"unexpandSubtype","description":""},{"name":"tacticFunext__","description":""},{"name":"«command_ClassAbbrev__:_:=__,»","description":""},{"name":"«tactic·.__;_»","description":"`· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. "},{"name":"solve","description":""},{"name":"Lean.Loop","description":""},{"name":"Lean.Loop.forIn","description":""},{"name":"Lean.Loop.forIn.loop","description":""},{"name":"Lean.instForInLoopUnit","description":""},{"name":"Lean.doElemRepeat_","description":""},{"name":"Lean.doElemWhile_Do_","description":""},{"name":"Lean.doElemRepeat_Until_","description":""},{"name":"StateRefT'","description":""},{"name":"StateRefT'.run","description":""},{"name":"StateRefT'.run'","description":""},{"name":"StateRefT'.lift","description":""},{"name":"StateRefT'.instMonadStateRefT'","description":""},{"name":"StateRefT'.instMonadLiftStateRefT'","description":""},{"name":"StateRefT'.instMonadFunctorStateRefT'","description":""},{"name":"StateRefT'.instAlternativeStateRefT'","description":""},{"name":"StateRefT'.get","description":""},{"name":"StateRefT'.set","description":""},{"name":"StateRefT'.modifyGet","description":""},{"name":"StateRefT'.instMonadStateOfStateRefT'","description":""},{"name":"StateRefT'.instMonadExceptOfStateRefT'","description":""},{"name":"instMonadControlStateRefT'","description":""},{"name":"instMonadFinallyStateRefT'","description":""},{"name":"dbgTrace","description":""},{"name":"dbgTraceVal","description":""},{"name":"dbgTraceIfShared","description":""},{"name":"dbgSleep","description":""},{"name":"panicWithPos","description":""},{"name":"panicWithPosWithDecl","description":""},{"name":"ptrAddrUnsafe","description":""},{"name":"withPtrAddrUnsafe","description":""},{"name":"withPtrEqUnsafe","description":""},{"name":"withPtrEq","description":""},{"name":"withPtrEqDecEq","description":"`withPtrEq` for `DecidableEq` "},{"name":"withPtrAddr","description":""},{"name":"Array.mkArray","description":""},{"name":"Array.size_mkArray","description":""},{"name":"Array.instEmptyCollectionArray","description":""},{"name":"Array.instInhabitedArray","description":""},{"name":"Array.isEmpty","description":""},{"name":"Array.singleton","description":""},{"name":"Array.uget","description":""},{"name":"Array.back","description":""},{"name":"Array.get?","description":""},{"name":"Array.back?","description":""},{"name":"Array.getLit","description":""},{"name":"Array.size_set","description":""},{"name":"Array.size_push","description":""},{"name":"Array.uset","description":""},{"name":"Array.swap","description":""},{"name":"Array.swap!","description":""},{"name":"Array.swapAt","description":""},{"name":"Array.swapAt!","description":""},{"name":"Array.pop","description":""},{"name":"Array.shrink","description":""},{"name":"Array.shrink.loop","description":""},{"name":"Array.modifyMUnsafe","description":""},{"name":"Array.modifyM","description":""},{"name":"Array.modify","description":""},{"name":"Array.modifyOp","description":""},{"name":"Array.forInUnsafe","description":""},{"name":"Array.forInUnsafe.loop","description":""},{"name":"Array.forIn","description":""},{"name":"Array.forIn.loop","description":""},{"name":"Array.instForInArray","description":""},{"name":"Array.foldlMUnsafe","description":""},{"name":"Array.foldlMUnsafe.fold","description":""},{"name":"Array.foldlM","description":""},{"name":"Array.foldlM.loop","description":""},{"name":"Array.foldrMUnsafe","description":""},{"name":"Array.foldrMUnsafe.fold","description":""},{"name":"Array.foldrM","description":""},{"name":"Array.foldrM.fold","description":""},{"name":"Array.mapMUnsafe","description":""},{"name":"Array.mapMUnsafe.map","description":""},{"name":"Array.mapM","description":""},{"name":"Array.mapIdxM","description":""},{"name":"Array.mapIdxM.map","description":""},{"name":"Array.findSomeM?","description":""},{"name":"Array.findM?","description":""},{"name":"Array.findIdxM?","description":""},{"name":"Array.anyMUnsafe","description":""},{"name":"Array.anyMUnsafe.any","description":""},{"name":"Array.anyM","description":""},{"name":"Array.anyM.loop","description":""},{"name":"Array.allM","description":""},{"name":"Array.findSomeRevM?","description":""},{"name":"Array.findSomeRevM?.find","description":""},{"name":"Array.findRevM?","description":""},{"name":"Array.forM","description":""},{"name":"Array.forRevM","description":""},{"name":"Array.foldl","description":""},{"name":"Array.foldr","description":""},{"name":"Array.map","description":""},{"name":"Array.mapIdx","description":""},{"name":"Array.find?","description":""},{"name":"Array.findSome?","description":""},{"name":"Array.findSome!","description":""},{"name":"Array.findSomeRev?","description":""},{"name":"Array.findRev?","description":""},{"name":"Array.findIdx?","description":""},{"name":"Array.findIdx?.loop","description":""},{"name":"Array.getIdx?","description":""},{"name":"Array.any","description":""},{"name":"Array.all","description":""},{"name":"Array.contains","description":""},{"name":"Array.elem","description":""},{"name":"Array.reverse","description":""},{"name":"Array.reverse.rev","description":""},{"name":"Array.getEvenElems","description":""},{"name":"Array.toList","description":""},{"name":"Array.instReprArray","description":""},{"name":"Array.instToStringArray","description":""},{"name":"Array.append","description":""},{"name":"Array.instAppendArray","description":""},{"name":"Array.appendList","description":""},{"name":"Array.instHAppendArrayList","description":""},{"name":"Array.concatMapM","description":""},{"name":"Array.concatMap","description":""},{"name":"«term#[_,]»","description":""},{"name":"Array.isEqvAux","description":""},{"name":"Array.isEqv","description":""},{"name":"Array.instBEqArray","description":""},{"name":"Array.filter","description":""},{"name":"Array.filterM","description":""},{"name":"Array.filterMapM","description":""},{"name":"Array.filterMap","description":""},{"name":"Array.getMax?","description":""},{"name":"Array.partition","description":""},{"name":"Array.ext","description":""},{"name":"Array.ext.extAux","description":""},{"name":"Array.extLit","description":""},{"name":"Array.indexOfAux","description":""},{"name":"Array.indexOf?","description":""},{"name":"Array.size_swap","description":""},{"name":"Array.size_pop","description":""},{"name":"Array.popWhile","description":""},{"name":"Array.takeWhile","description":""},{"name":"Array.takeWhile.go","description":""},{"name":"Array.eraseIdxAux","description":""},{"name":"Array.feraseIdx","description":""},{"name":"Array.eraseIdx","description":""},{"name":"Array.eraseIdxSzAux","description":""},{"name":"Array.eraseIdx'","description":""},{"name":"Array.erase","description":""},{"name":"Array.insertAtAux","description":""},{"name":"Array.insertAt","description":"Insert element `a` at position `i`.\n  Pre: `i < as.size` "},{"name":"Array.toListLitAux","description":""},{"name":"Array.toArrayLit","description":""},{"name":"Array.toArrayLit_eq","description":""},{"name":"Array.isPrefixOfAux","description":""},{"name":"Array.isPrefixOf","description":""},{"name":"Array.allDiff","description":""},{"name":"Array.zipWithAux","description":""},{"name":"Array.zipWith","description":""},{"name":"Array.zip","description":""},{"name":"Array.unzip","description":""},{"name":"Array.split","description":""},{"name":"Lean.Parser.Tactic.Conv.conv.quot","description":""},{"name":"Lean.Parser.Tactic.Conv.convSeq1Indented","description":""},{"name":"Lean.Parser.Tactic.Conv.convSeqBracketed","description":""},{"name":"Lean.Parser.Tactic.Conv.convSeq","description":""},{"name":"Lean.Parser.Tactic.Conv.conv","description":""},{"name":"Lean.Parser.Tactic.Conv.lhs","description":""},{"name":"Lean.Parser.Tactic.Conv.rhs","description":""},{"name":"Lean.Parser.Tactic.Conv.whnf","description":""},{"name":"Lean.Parser.Tactic.Conv.reduce","description":"Put term in normal form, this tactic is ment for debugging purposes only "},{"name":"Lean.Parser.Tactic.Conv.congr","description":""},{"name":"Lean.Parser.Tactic.Conv.arg","description":""},{"name":"Lean.Parser.Tactic.Conv.ext","description":""},{"name":"Lean.Parser.Tactic.Conv.change","description":""},{"name":"Lean.Parser.Tactic.Conv.delta","description":""},{"name":"Lean.Parser.Tactic.Conv.unfold","description":""},{"name":"Lean.Parser.Tactic.Conv.pattern","description":""},{"name":"Lean.Parser.Tactic.Conv.rewrite","description":""},{"name":"Lean.Parser.Tactic.Conv.simp","description":""},{"name":"Lean.Parser.Tactic.Conv.simpMatch","description":""},{"name":"Lean.Parser.Tactic.Conv.nestedTacticCore","description":"Execute the given tactic block without converting `conv` goal into a regular goal "},{"name":"Lean.Parser.Tactic.Conv.nestedTactic","description":"Focus, convert the `conv` goal `⊢ lhs` into a regular goal `⊢ lhs = rhs`, and then execute the given tactic block. "},{"name":"Lean.Parser.Tactic.Conv.nestedConv","description":""},{"name":"Lean.Parser.Tactic.Conv.paren","description":""},{"name":"Lean.Parser.Tactic.Conv.convConvSeq","description":""},{"name":"Lean.Parser.Tactic.Conv.«conv·._»","description":"`· conv` focuses on the main conv goal and tries to solve it using `s` "},{"name":"Lean.Parser.Tactic.Conv.convRw__","description":""},{"name":"Lean.Parser.Tactic.Conv.convErw_","description":""},{"name":"Lean.Parser.Tactic.Conv.convArgs","description":""},{"name":"Lean.Parser.Tactic.Conv.convLeft","description":""},{"name":"Lean.Parser.Tactic.Conv.convRight","description":""},{"name":"Lean.Parser.Tactic.Conv.convIntro___","description":""},{"name":"Lean.Parser.Tactic.Conv.enterArg","description":""},{"name":"Lean.Parser.Tactic.Conv.«convEnter[__]»","description":""},{"name":"Lean.Parser.Tactic.Conv.convSkip","description":""},{"name":"Lean.Parser.Tactic.Conv.convDone","description":""},{"name":"Lean.Parser.Tactic.Conv.convTrace_state","description":""},{"name":"Lean.Parser.Tactic.Conv.convApply_","description":""},{"name":"Lean.Parser.Tactic.Conv.first","description":"`first | conv | ...` runs each `conv` until one succeeds, or else fails. "},{"name":"Lean.Parser.Tactic.Conv.convRepeat_","description":""},{"name":"Option.get!","description":""},{"name":"Repr","description":""},{"name":"repr","description":""},{"name":"reprStr","description":""},{"name":"reprArg","description":""},{"name":"ReprAtom","description":""},{"name":"instReprIdType","description":""},{"name":"instReprId","description":""},{"name":"instReprBool","description":""},{"name":"Repr.addAppParen","description":""},{"name":"instReprDecidable","description":""},{"name":"instReprPUnit","description":""},{"name":"instReprULift","description":""},{"name":"instReprUnit","description":""},{"name":"instReprOption","description":""},{"name":"instReprSum","description":""},{"name":"ReprTuple","description":""},{"name":"instReprTuple","description":""},{"name":"instReprTupleProd","description":""},{"name":"instReprProd","description":""},{"name":"instReprSigma","description":""},{"name":"instReprSubtype","description":""},{"name":"Nat.digitChar","description":""},{"name":"Nat.toDigitsCore","description":""},{"name":"Nat.toDigits","description":""},{"name":"Nat.repr","description":""},{"name":"Nat.superDigitChar","description":""},{"name":"Nat.toSuperDigitsAux","description":""},{"name":"Nat.toSuperDigits","description":""},{"name":"Nat.toSuperscriptString","description":""},{"name":"instReprNat","description":""},{"name":"Int.repr","description":""},{"name":"instReprInt","description":""},{"name":"hexDigitRepr","description":""},{"name":"charToHex","description":""},{"name":"Char.quoteCore","description":""},{"name":"Char.quote","description":""},{"name":"instReprChar","description":""},{"name":"Char.repr","description":""},{"name":"String.quote","description":""},{"name":"instReprString","description":""},{"name":"instReprSubstring","description":""},{"name":"instReprIterator","description":""},{"name":"instReprFin","description":""},{"name":"instReprUInt8","description":""},{"name":"instReprUInt16","description":""},{"name":"instReprUInt32","description":""},{"name":"instReprUInt64","description":""},{"name":"instReprUSize","description":""},{"name":"instReprList","description":""},{"name":"instReprList_1","description":""},{"name":"instReprAtomBool","description":""},{"name":"instReprAtomNat","description":""},{"name":"instReprAtomInt","description":""},{"name":"instReprAtomChar","description":""},{"name":"instReprAtomString","description":""},{"name":"instReprAtomUInt8","description":""},{"name":"instReprAtomUInt16","description":""},{"name":"instReprAtomUInt32","description":""},{"name":"instReprAtomUInt64","description":""},{"name":"instReprAtomUSize","description":""},{"name":"instReprSourceInfo","description":""},{"name":"Std.Format.FlattenBehavior","description":""},{"name":"Std.Format.instInhabitedFlattenBehavior","description":""},{"name":"Std.Format.instBEqFlattenBehavior","description":""},{"name":"Std.Format","description":""},{"name":"Std.instInhabitedFormat","description":""},{"name":"Std.Format.isEmpty","description":""},{"name":"Std.Format.fill","description":""},{"name":"Std.Format.appendEx","description":""},{"name":"Std.Format.groupEx","description":""},{"name":"Std.Format.instAppendFormat","description":""},{"name":"Std.Format.instCoeStringFormat","description":""},{"name":"Std.Format.join","description":""},{"name":"Std.Format.isNil","description":""},{"name":"Std.Format.instInhabitedSpaceResult","description":""},{"name":"Std.Format.MonadPrettyFormat","description":"A monad in which we can pretty-print `Format` objects. "},{"name":"Std.Format.prettyM","description":""},{"name":"Std.Format.bracket","description":""},{"name":"Std.Format.paren","description":""},{"name":"Std.Format.sbracket","description":""},{"name":"Std.Format.bracketFill","description":""},{"name":"Std.Format.defIndent","description":""},{"name":"Std.Format.defUnicode","description":""},{"name":"Std.Format.defWidth","description":""},{"name":"Std.Format.nestD","description":""},{"name":"Std.Format.indentD","description":""},{"name":"Std.Format.instMonadPrettyFormatStateMState","description":""},{"name":"Std.Format.pretty","description":"Pretty-print a `Format` object as a string with expected width `w`. "},{"name":"Std.ToFormat","description":""},{"name":"Std.instToFormatFormat","description":""},{"name":"Std.instToFormatString","description":""},{"name":"Std.Format.joinSep","description":""},{"name":"Std.Format.prefixJoin","description":""},{"name":"Std.Format.joinSuffix","description":""},{"name":"EStateM.instToStringResult","description":""},{"name":"EStateM.instReprResult","description":""},{"name":"EStateM.orElse'","description":"Alternative orElse operator that allows to select which exception should be used.\n    The default is to use the first exception since the standard `orElse` uses the second. "},{"name":"EStateM.instMonadFinallyEStateM","description":""},{"name":"EStateM.fromStateM","description":""},{"name":"Socket.initSocket","description":"The initialization function. Users shouldn't call this it. "},{"name":"Std.Range","description":""},{"name":"Std.Range.forIn","description":""},{"name":"Std.Range.forIn.loop","description":""},{"name":"Std.Range.instForInRangeNat","description":""},{"name":"Std.Range.forM","description":""},{"name":"Std.Range.forM.loop","description":""},{"name":"Std.Range.instForMRangeNat","description":""},{"name":"Std.Range.«term[:_]»","description":""},{"name":"Std.Range.«term[_:_]»","description":""},{"name":"Std.Range.«term[:_:_]»","description":""},{"name":"Std.Range.«term[_:_:_]»","description":""},{"name":"Lean.version.major","description":""},{"name":"Lean.version.minor","description":""},{"name":"Lean.version.patch","description":""},{"name":"Lean.getGithash","description":""},{"name":"Lean.githash","description":""},{"name":"Lean.version.getIsRelease","description":""},{"name":"Lean.version.isRelease","description":""},{"name":"Lean.version.getSpecialDesc","description":"Additional version description like \"nightly-2018-03-11\" "},{"name":"Lean.version.specialDesc","description":""},{"name":"Lean.versionStringCore","description":""},{"name":"Lean.versionString","description":""},{"name":"Lean.origin","description":""},{"name":"Lean.toolchain","description":""},{"name":"Lean.isGreek","description":""},{"name":"Lean.isLetterLike","description":""},{"name":"Lean.isNumericSubscript","description":""},{"name":"Lean.isSubScriptAlnum","description":""},{"name":"Lean.isIdFirst","description":""},{"name":"Lean.isIdRest","description":""},{"name":"Lean.idBeginEscape","description":""},{"name":"Lean.idEndEscape","description":""},{"name":"Lean.isIdBeginEscape","description":""},{"name":"Lean.isIdEndEscape","description":""},{"name":"Lean.Name.getRoot","description":""},{"name":"Lean.Name.isInaccessibleUserName","description":""},{"name":"Lean.Name.escapePart","description":""},{"name":"Lean.Name.toStringWithSep","description":""},{"name":"Lean.Name.toStringWithSep.maybeEscape","description":""},{"name":"Lean.Name.toString","description":""},{"name":"Lean.Name.toString.maybePseudoSyntax","description":""},{"name":"Lean.Name.instToStringName","description":""},{"name":"Lean.Name.reprPrec","description":""},{"name":"Lean.Name.instReprName","description":""},{"name":"Lean.Name.instReprSyntax","description":""},{"name":"Lean.Name.capitalize","description":""},{"name":"Lean.Name.replacePrefix","description":""},{"name":"Lean.Name.modifyBase","description":"Remove macros scopes, apply `f`, and put them back "},{"name":"Lean.Name.appendAfter","description":""},{"name":"Lean.Name.appendIndexAfter","description":""},{"name":"Lean.Name.appendBefore","description":""},{"name":"Lean.NameGenerator","description":""},{"name":"Lean.instInhabitedNameGenerator","description":""},{"name":"Lean.NameGenerator.curr","description":""},{"name":"Lean.NameGenerator.next","description":""},{"name":"Lean.NameGenerator.mkChild","description":""},{"name":"Lean.MonadNameGenerator","description":""},{"name":"Lean.mkFreshId","description":""},{"name":"Lean.monadNameGeneratorLift","description":""},{"name":"Lean.Syntax.structEq","description":""},{"name":"Lean.Syntax.instBEqSyntax","description":""},{"name":"Lean.Syntax.getTailInfo?","description":""},{"name":"Lean.Syntax.getTailInfo","description":""},{"name":"Lean.Syntax.getTrailingSize","description":""},{"name":"Lean.Syntax.getSubstring?","description":"Return substring of original input covering `stx`.\n  Result is meaningful only if all involved `SourceInfo.original`s refer to the same string (as is the case after parsing). "},{"name":"Lean.Syntax.setTailInfoAux","description":""},{"name":"Lean.Syntax.setTailInfo","description":""},{"name":"Lean.Syntax.unsetTrailing","description":""},{"name":"Lean.Syntax.setHeadInfoAux","description":""},{"name":"Lean.Syntax.setHeadInfo","description":""},{"name":"Lean.Syntax.setInfo","description":""},{"name":"Lean.Syntax.getHead?","description":"Return the first atom/identifier that has position information "},{"name":"Lean.Syntax.copyHeadTailInfoFrom","description":""},{"name":"Lean.Syntax.mkSynthetic","description":"Ensure head position is synthetic. The server regards syntax as \"original\" only if both head and tail info are `original`. "},{"name":"Lean.withHeadRefOnly","description":"Use the head atom/identifier of the current `ref` as the `ref` "},{"name":"Lean.mkNode","description":""},{"name":"Lean.Module","description":""},{"name":"Lean.expandMacros","description":"Expand all macros in the given syntax "},{"name":"Lean.mkIdentFrom","description":"Create an identifier copying the position from `src`.\n  To refer to a specific constant, use `mkCIdentFrom` instead. "},{"name":"Lean.mkIdentFromRef","description":""},{"name":"Lean.mkCIdentFrom","description":"Create an identifier referring to a constant `c` copying the position from `src`.\n  This variant of `mkIdentFrom` makes sure that the identifier cannot accidentally\n  be captured. "},{"name":"Lean.mkCIdentFromRef","description":""},{"name":"Lean.mkCIdent","description":""},{"name":"Lean.mkIdent","description":""},{"name":"Lean.mkNullNode","description":""},{"name":"Lean.mkGroupNode","description":""},{"name":"Lean.mkSepArray","description":""},{"name":"Lean.mkOptionalNode","description":""},{"name":"Lean.mkHole","description":""},{"name":"Lean.Syntax.mkSep","description":""},{"name":"Lean.Syntax.SepArray.ofElems","description":""},{"name":"Lean.Syntax.SepArray.ofElemsUsingRef","description":""},{"name":"Lean.Syntax.instCoeArraySyntaxSepArray","description":""},{"name":"Lean.Syntax.mkApp","description":"Create syntax representing a Lean term application, but avoid degenerate empty applications. "},{"name":"Lean.Syntax.mkCApp","description":""},{"name":"Lean.Syntax.mkLit","description":""},{"name":"Lean.Syntax.mkStrLit","description":""},{"name":"Lean.Syntax.mkNumLit","description":""},{"name":"Lean.Syntax.mkScientificLit","description":""},{"name":"Lean.Syntax.mkNameLit","description":""},{"name":"Lean.Syntax.decodeNatLitVal?","description":""},{"name":"Lean.Syntax.isLit?","description":""},{"name":"Lean.Syntax.isNatLit?","description":""},{"name":"Lean.Syntax.isFieldIdx?","description":""},{"name":"Lean.Syntax.decodeScientificLitVal?","description":""},{"name":"Lean.Syntax.decodeScientificLitVal?.decodeAfterExp","description":""},{"name":"Lean.Syntax.decodeScientificLitVal?.decodeExp","description":""},{"name":"Lean.Syntax.decodeScientificLitVal?.decodeAfterDot","description":""},{"name":"Lean.Syntax.decodeScientificLitVal?.decode","description":""},{"name":"Lean.Syntax.isScientificLit?","description":""},{"name":"Lean.Syntax.isIdOrAtom?","description":""},{"name":"Lean.Syntax.toNat","description":""},{"name":"Lean.Syntax.decodeQuotedChar","description":""},{"name":"Lean.Syntax.decodeStrLitAux","description":""},{"name":"Lean.Syntax.decodeStrLit","description":""},{"name":"Lean.Syntax.isStrLit?","description":""},{"name":"Lean.Syntax.decodeCharLit","description":""},{"name":"Lean.Syntax.isCharLit?","description":""},{"name":"Lean.Syntax.splitNameLit","description":"Split a name literal (without the backtick) into its dot-separated components. For example,\n`foo.bla.«bo.o»` ↦ `[\"foo\", \"bla\", \"«bo.o»\"]`. If the literal cannot be parsed, return `[]`. "},{"name":"Lean.Syntax.decodeNameLit","description":""},{"name":"Lean.Syntax.isNameLit?","description":""},{"name":"Lean.Syntax.hasArgs","description":""},{"name":"Lean.Syntax.isAtom","description":""},{"name":"Lean.Syntax.isToken","description":""},{"name":"Lean.Syntax.isNone","description":""},{"name":"Lean.Syntax.getOptional?","description":""},{"name":"Lean.Syntax.getOptionalIdent?","description":""},{"name":"Lean.Syntax.findAux","description":""},{"name":"Lean.Syntax.find?","description":""},{"name":"Lean.Quote","description":"Reflect a runtime datum back to surface syntax (best-effort). "},{"name":"Lean.instQuoteSyntax","description":""},{"name":"Lean.instQuoteBool","description":""},{"name":"Lean.instQuoteString","description":""},{"name":"Lean.instQuoteNat","description":""},{"name":"Lean.instQuoteSubstring","description":""},{"name":"Lean.instQuoteName","description":""},{"name":"Lean.instQuoteProd","description":""},{"name":"Lean.instQuoteList","description":""},{"name":"Lean.instQuoteArray","description":""},{"name":"Lean.Option.hasQuote","description":""},{"name":"Lean.evalPrec","description":""},{"name":"Lean.termEval_prec_","description":""},{"name":"Lean.evalPrio","description":""},{"name":"Lean.termEval_prio_","description":""},{"name":"Lean.evalOptPrio","description":""},{"name":"Array.getSepElems","description":""},{"name":"Array.filterSepElemsM","description":""},{"name":"Array.filterSepElems","description":""},{"name":"Array.mapSepElemsM","description":""},{"name":"Array.mapSepElems","description":""},{"name":"Lean.Syntax.SepArray.getElems","description":""},{"name":"Lean.Syntax.SepArray.instCoeTailSepArrayArraySyntax","description":""},{"name":"autoParam","description":"Gadget for automatic parameter support. This is similar to the `optParam` gadget, but it uses\n  the given tactic.\n  Like `optParam`, this gadget only affects elaboration.\n  For example, the tactic will *not* be invoked during type class resolution. "},{"name":"Lean.Syntax.isInterpolatedStrLit?","description":""},{"name":"Lean.Syntax.expandInterpolatedStrChunks","description":""},{"name":"Lean.Syntax.expandInterpolatedStr","description":""},{"name":"Lean.Syntax.getSepArgs","description":""},{"name":"Lean.Meta.TransparencyMode","description":""},{"name":"Lean.Meta.instInhabitedTransparencyMode","description":""},{"name":"Lean.Meta.instBEqTransparencyMode","description":""},{"name":"Lean.Meta.instReprTransparencyMode","description":""},{"name":"Lean.Meta.Simp.defaultMaxSteps","description":""},{"name":"Lean.Meta.Simp.Config","description":""},{"name":"Lean.Meta.Simp.instInhabitedConfig","description":""},{"name":"Lean.Meta.Simp.instBEqConfig","description":""},{"name":"Lean.Meta.Simp.instReprConfig","description":""},{"name":"Lean.Meta.Simp.ConfigCtx","description":""},{"name":"Lean.Meta.Simp.neutralConfig","description":""},{"name":"Lean.Meta.Rewrite.Config","description":""},{"name":"Lean.Parser.Tactic.tacticErw__","description":""},{"name":"Lean.Parser.Tactic.simpArith","description":"Similar to `simp` but with `arith := true` "},{"name":"Lean.Parser.Tactic.expandSimpArith","description":""},{"name":"Fin.coeToNat","description":""},{"name":"Fin.elim0","description":""},{"name":"Fin.ofNat","description":""},{"name":"Fin.ofNat'","description":""},{"name":"Fin.add","description":""},{"name":"Fin.mul","description":""},{"name":"Fin.sub","description":""},{"name":"Fin.mod","description":""},{"name":"Fin.div","description":""},{"name":"Fin.modn","description":""},{"name":"Fin.land","description":""},{"name":"Fin.lor","description":""},{"name":"Fin.xor","description":""},{"name":"Fin.shiftLeft","description":""},{"name":"Fin.shiftRight","description":""},{"name":"Fin.instAddFin","description":""},{"name":"Fin.instSubFin","description":""},{"name":"Fin.instMulFin","description":""},{"name":"Fin.instModFin","description":""},{"name":"Fin.instDivFin","description":""},{"name":"Fin.instAndOpFin","description":""},{"name":"Fin.instOrOpFin","description":""},{"name":"Fin.instXorFin","description":""},{"name":"Fin.instShiftLeftFin","description":""},{"name":"Fin.instShiftRightFin","description":""},{"name":"Fin.instHModFinNat","description":""},{"name":"Fin.instOfNatFinHAddNatInstHAddInstAddNatOfNat","description":""},{"name":"Fin.instInhabitedFinHAddNatInstHAddInstAddNatOfNat","description":""},{"name":"Fin.val_ne_of_ne","description":""},{"name":"Fin.modn_lt","description":""},{"name":"Id","description":""},{"name":"Id.instMonadId","description":""},{"name":"Id.hasBind","description":""},{"name":"Id.run","description":""},{"name":"Id.instOfNatId","description":""},{"name":"String.toNat!","description":""},{"name":"String.fromUTF8Unchecked","description":"Convert a UTF-8 encoded `ByteArray` string to `String`.\n  The result is unspecified if `a` is not properly UTF-8 encoded. "},{"name":"String.toUTF8","description":""},{"name":"Int","description":""},{"name":"instCoeNatInt","description":""},{"name":"instOfNatInt","description":""},{"name":"Int.instInhabitedInt","description":""},{"name":"Int.negOfNat","description":""},{"name":"Int.neg","description":""},{"name":"Int.subNatNat","description":""},{"name":"Int.add","description":""},{"name":"Int.mul","description":""},{"name":"Int.instNegInt","description":""},{"name":"Int.instAddInt","description":""},{"name":"Int.instMulInt","description":""},{"name":"Int.sub","description":""},{"name":"Int.instSubInt","description":""},{"name":"Int.NonNeg","description":""},{"name":"Int.le","description":""},{"name":"Int.instLEInt","description":""},{"name":"Int.lt","description":""},{"name":"Int.instLTInt","description":""},{"name":"Int.decEq","description":""},{"name":"Int.instDecidableEqInt","description":""},{"name":"Int.decLe","description":""},{"name":"Int.decLt","description":""},{"name":"Int.natAbs","description":""},{"name":"Int.instOfNatInt","description":""},{"name":"Int.div","description":""},{"name":"Int.mod","description":""},{"name":"Int.instDivInt","description":""},{"name":"Int.instModInt","description":""},{"name":"Int.toNat","description":""},{"name":"Int.natMod","description":""},{"name":"Int.pow","description":""},{"name":"Int.instHPowIntNat","description":""},{"name":"Nat.log2","description":"Computes `⌊max 0 (log₂ n)⌋`.\n\n`log2 0 = log2 1 = 0`, `log2 2 = 1`, ..., `log2 (2^i) = i`, etc.\n"},{"name":"StateCpsT","description":""},{"name":"StateCpsT.runK","description":""},{"name":"StateCpsT.run","description":""},{"name":"StateCpsT.run'","description":""},{"name":"StateCpsT.instMonadStateCpsT","description":""},{"name":"StateCpsT.instLawfulMonadStateCpsTInstMonadStateCpsT","description":""},{"name":"StateCpsT.instMonadStateOfStateCpsT","description":""},{"name":"StateCpsT.lift","description":""},{"name":"StateCpsT.instMonadLiftStateCpsT","description":""},{"name":"StateCpsT.runK_pure","description":""},{"name":"StateCpsT.runK_get","description":""},{"name":"StateCpsT.runK_set","description":""},{"name":"StateCpsT.runK_modify","description":""},{"name":"StateCpsT.runK_lift","description":""},{"name":"StateCpsT.runK_monadLift","description":""},{"name":"StateCpsT.runK_bind_pure","description":""},{"name":"StateCpsT.runK_bind_lift","description":""},{"name":"StateCpsT.runK_bind_get","description":""},{"name":"StateCpsT.runK_bind_set","description":""},{"name":"StateCpsT.runK_bind_modify","description":""},{"name":"StateCpsT.run_eq","description":""},{"name":"StateCpsT.run'_eq","description":""},{"name":"Except.pure","description":""},{"name":"Except.map","description":""},{"name":"Except.map_id","description":""},{"name":"Except.mapError","description":""},{"name":"Except.bind","description":""},{"name":"Except.toBool","description":""},{"name":"Except.toOption","description":""},{"name":"Except.tryCatch","description":""},{"name":"Except.orElseLazy","description":""},{"name":"Except.instMonadExcept","description":""},{"name":"ExceptT","description":""},{"name":"ExceptT.mk","description":""},{"name":"ExceptT.run","description":""},{"name":"ExceptT.pure","description":""},{"name":"ExceptT.bindCont","description":""},{"name":"ExceptT.bind","description":""},{"name":"ExceptT.map","description":""},{"name":"ExceptT.lift","description":""},{"name":"ExceptT.instMonadLiftExceptExceptT","description":""},{"name":"ExceptT.instMonadLiftExceptT","description":""},{"name":"ExceptT.tryCatch","description":""},{"name":"ExceptT.instMonadFunctorExceptT","description":""},{"name":"ExceptT.instMonadExceptT","description":""},{"name":"ExceptT.adapt","description":""},{"name":"instMonadExceptOfExceptT","description":""},{"name":"instMonadExceptOfExceptT_1","description":""},{"name":"instInhabitedExceptT","description":""},{"name":"instMonadExceptOfExcept","description":""},{"name":"MonadExcept.orelse'","description":"Alternative orelse operator that allows to select which exception should be used.\n    The default is to use the first exception since the standard `orelse` uses the second. "},{"name":"observing","description":""},{"name":"liftExcept","description":""},{"name":"instMonadControlExceptT","description":""},{"name":"MonadFinally","description":""},{"name":"tryFinally","description":"Execute `x` and then execute `finalizer` even if `x` threw an exception "},{"name":"Id.finally","description":""},{"name":"ExceptT.finally","description":""},{"name":"id","description":""},{"name":"Function.comp","description":""},{"name":"Function.const","description":""},{"name":"inferInstance","description":""},{"name":"inferInstanceAs","description":""},{"name":"PUnit","description":""},{"name":"Unit","description":"An abbreviation for `PUnit.{0}`, its most common instantiation.\n    This Type should be preferred over `PUnit` where possible to avoid\n    unnecessary universe parameters. "},{"name":"Unit.unit","description":""},{"name":"lcProof","description":"Auxiliary unsafe constant used by the Compiler when erasing proofs from code. "},{"name":"lcUnreachable","description":"Auxiliary unsafe constant used by the Compiler to mark unreachable code. "},{"name":"True","description":""},{"name":"False","description":""},{"name":"Empty","description":""},{"name":"PEmpty","description":""},{"name":"Not","description":""},{"name":"False.elim","description":""},{"name":"absurd","description":""},{"name":"Eq","description":""},{"name":"rfl","description":""},{"name":"id_eq","description":""},{"name":"Eq.subst","description":""},{"name":"Eq.symm","description":""},{"name":"Eq.trans","description":""},{"name":"cast","description":""},{"name":"congrArg","description":""},{"name":"congr","description":""},{"name":"congrFun","description":""},{"name":"HEq","description":""},{"name":"HEq.rfl","description":""},{"name":"eq_of_heq","description":""},{"name":"Prod","description":""},{"name":"PProd","description":"Similar to `Prod`, but `α` and `β` can be propositions.\n   We use this Type internally to automatically generate the brecOn recursor. "},{"name":"MProd","description":"Similar to `Prod`, but `α` and `β` are in the same universe. "},{"name":"And","description":""},{"name":"Or","description":""},{"name":"Or.intro_left","description":""},{"name":"Or.intro_right","description":""},{"name":"Or.elim","description":""},{"name":"Bool","description":""},{"name":"Subtype","description":""},{"name":"optParam","description":"Gadget for optional parameter support. "},{"name":"outParam","description":"Gadget for marking output parameters in type classes. "},{"name":"typedExpr","description":"Auxiliary Declaration used to implement the notation (a : α) "},{"name":"namedPattern","description":"Auxiliary Declaration used to implement the named patterns `x@h:p` "},{"name":"sorryAx","description":""},{"name":"eq_false_of_ne_true","description":""},{"name":"eq_true_of_ne_false","description":""},{"name":"ne_false_of_eq_true","description":""},{"name":"ne_true_of_eq_false","description":""},{"name":"Inhabited","description":""},{"name":"Nonempty","description":""},{"name":"Classical.choice","description":""},{"name":"Nonempty.elim","description":""},{"name":"instNonempty","description":""},{"name":"Classical.ofNonempty","description":""},{"name":"instNonemptyForAll","description":""},{"name":"instNonemptyForAll_1","description":""},{"name":"instInhabitedSort","description":""},{"name":"instInhabitedForAll","description":""},{"name":"instInhabitedForAll_1","description":""},{"name":"instInhabitedBool","description":""},{"name":"PLift","description":"Universe lifting operation from Sort to Type "},{"name":"PLift.up_down","description":""},{"name":"PLift.down_up","description":""},{"name":"NonemptyType","description":""},{"name":"NonemptyType.type","description":""},{"name":"instInhabitedNonemptyType","description":""},{"name":"ULift","description":"Universe lifting operation "},{"name":"ULift.up_down","description":""},{"name":"ULift.down_up","description":""},{"name":"Decidable","description":""},{"name":"Decidable.decide","description":""},{"name":"DecidablePred","description":""},{"name":"DecidableRel","description":""},{"name":"DecidableEq","description":""},{"name":"decEq","description":""},{"name":"decide_eq_true","description":""},{"name":"decide_eq_false","description":""},{"name":"of_decide_eq_true","description":""},{"name":"of_decide_eq_false","description":""},{"name":"of_decide_eq_self_eq_true","description":""},{"name":"instDecidableEqBool","description":""},{"name":"BEq","description":""},{"name":"instBEq","description":""},{"name":"dite","description":""},{"name":"ite","description":""},{"name":"instDecidableAnd","description":""},{"name":"instDecidableOr","description":""},{"name":"instDecidableNot","description":""},{"name":"cond","description":""},{"name":"or","description":""},{"name":"and","description":""},{"name":"not","description":""},{"name":"Nat","description":""},{"name":"instInhabitedNat","description":""},{"name":"OfNat","description":""},{"name":"instOfNatNat","description":""},{"name":"LE","description":""},{"name":"LT","description":""},{"name":"GE.ge","description":""},{"name":"GT.gt","description":""},{"name":"max","description":""},{"name":"min","description":""},{"name":"Trans","description":"Transitive chaining of proofs, used e.g. by `calc`. "},{"name":"instTransEq","description":""},{"name":"instTransEq_1","description":""},{"name":"HAdd","description":""},{"name":"HSub","description":""},{"name":"HMul","description":""},{"name":"HDiv","description":""},{"name":"HMod","description":""},{"name":"HPow","description":""},{"name":"HAppend","description":""},{"name":"HOrElse","description":""},{"name":"HAndThen","description":""},{"name":"HAnd","description":""},{"name":"HXor","description":""},{"name":"HOr","description":""},{"name":"HShiftLeft","description":""},{"name":"HShiftRight","description":""},{"name":"Add","description":""},{"name":"Sub","description":""},{"name":"Mul","description":""},{"name":"Neg","description":""},{"name":"Div","description":""},{"name":"Mod","description":""},{"name":"Pow","description":""},{"name":"Append","description":""},{"name":"OrElse","description":""},{"name":"AndThen","description":""},{"name":"AndOp","description":""},{"name":"Xor","description":""},{"name":"OrOp","description":""},{"name":"Complement","description":""},{"name":"ShiftLeft","description":""},{"name":"ShiftRight","description":""},{"name":"instHAdd","description":""},{"name":"instHSub","description":""},{"name":"instHMul","description":""},{"name":"instHDiv","description":""},{"name":"instHMod","description":""},{"name":"instHPow","description":""},{"name":"instHAppend","description":""},{"name":"instHOrElse","description":""},{"name":"instHAndThen","description":""},{"name":"instHAnd","description":""},{"name":"instHXor","description":""},{"name":"instHOr","description":""},{"name":"instHShiftLeft","description":""},{"name":"instHShiftRight","description":""},{"name":"Nat.add","description":""},{"name":"instAddNat","description":""},{"name":"Nat.mul","description":""},{"name":"instMulNat","description":""},{"name":"Nat.pow","description":""},{"name":"instPowNat","description":""},{"name":"Nat.beq","description":""},{"name":"instBEqNat","description":""},{"name":"Nat.eq_of_beq_eq_true","description":""},{"name":"Nat.ne_of_beq_eq_false","description":""},{"name":"Nat.decEq","description":""},{"name":"instDecidableEqNat","description":""},{"name":"Nat.ble","description":""},{"name":"Nat.le","description":""},{"name":"instLENat","description":""},{"name":"Nat.lt","description":""},{"name":"instLTNat","description":""},{"name":"Nat.not_succ_le_zero","description":""},{"name":"Nat.not_lt_zero","description":""},{"name":"Nat.zero_le","description":""},{"name":"Nat.succ_le_succ","description":""},{"name":"Nat.zero_lt_succ","description":""},{"name":"Nat.le_step","description":""},{"name":"Nat.le_trans","description":""},{"name":"Nat.lt_trans","description":""},{"name":"Nat.le_succ","description":""},{"name":"Nat.le_succ_of_le","description":""},{"name":"Nat.le_refl","description":""},{"name":"Nat.succ_pos","description":""},{"name":"Nat.pred","description":""},{"name":"Nat.pred_le_pred","description":""},{"name":"Nat.le_of_succ_le_succ","description":""},{"name":"Nat.le_of_lt_succ","description":""},{"name":"Nat.eq_or_lt_of_le","description":""},{"name":"Nat.lt_or_ge","description":""},{"name":"Nat.not_succ_le_self","description":""},{"name":"Nat.lt_irrefl","description":""},{"name":"Nat.lt_of_le_of_lt","description":""},{"name":"Nat.le_antisymm","description":""},{"name":"Nat.lt_of_le_of_ne","description":""},{"name":"Nat.le_of_ble_eq_true","description":""},{"name":"Nat.ble_self_eq_true","description":""},{"name":"Nat.ble_succ_eq_true","description":""},{"name":"Nat.ble_eq_true_of_le","description":""},{"name":"Nat.not_le_of_not_ble_eq_true","description":""},{"name":"Nat.decLe","description":""},{"name":"Nat.decLt","description":""},{"name":"Nat.sub","description":""},{"name":"instSubNat","description":""},{"name":"System.Platform.getNumBits","description":""},{"name":"System.Platform.numBits","description":""},{"name":"System.Platform.numBits_eq","description":""},{"name":"Fin","description":""},{"name":"Fin.eq_of_val_eq","description":""},{"name":"Fin.val_eq_of_eq","description":""},{"name":"Fin.ne_of_val_ne","description":""},{"name":"instDecidableEqFin","description":""},{"name":"instLTFin","description":""},{"name":"instLEFin","description":""},{"name":"Fin.decLt","description":""},{"name":"Fin.decLe","description":""},{"name":"UInt8.size","description":""},{"name":"UInt8","description":""},{"name":"UInt8.ofNatCore","description":""},{"name":"UInt8.decEq","description":""},{"name":"instDecidableEqUInt8","description":""},{"name":"instInhabitedUInt8","description":""},{"name":"UInt16.size","description":""},{"name":"UInt16","description":""},{"name":"UInt16.ofNatCore","description":""},{"name":"UInt16.decEq","description":""},{"name":"instDecidableEqUInt16","description":""},{"name":"instInhabitedUInt16","description":""},{"name":"UInt32.size","description":""},{"name":"UInt32","description":""},{"name":"UInt32.ofNatCore","description":""},{"name":"UInt32.toNat","description":""},{"name":"UInt32.decEq","description":""},{"name":"instDecidableEqUInt32","description":""},{"name":"instInhabitedUInt32","description":""},{"name":"instLTUInt32","description":""},{"name":"instLEUInt32","description":""},{"name":"UInt32.decLt","description":""},{"name":"UInt32.decLe","description":""},{"name":"instDecidableLtUInt32InstLTUInt32","description":""},{"name":"instDecidableLeUInt32InstLEUInt32","description":""},{"name":"UInt64.size","description":""},{"name":"UInt64","description":""},{"name":"UInt64.ofNatCore","description":""},{"name":"UInt64.decEq","description":""},{"name":"instDecidableEqUInt64","description":""},{"name":"instInhabitedUInt64","description":""},{"name":"USize.size","description":""},{"name":"usize_size_eq","description":""},{"name":"USize","description":""},{"name":"USize.ofNatCore","description":""},{"name":"USize.decEq","description":""},{"name":"instDecidableEqUSize","description":""},{"name":"instInhabitedUSize","description":""},{"name":"USize.ofNat32","description":""},{"name":"Nat.isValidChar","description":""},{"name":"UInt32.isValidChar","description":""},{"name":"Char","description":"The `Char` Type represents an unicode scalar value.\n    See http://www.unicode.org/glossary/#unicode_scalar_value). "},{"name":"Char.ofNatAux","description":""},{"name":"Char.ofNat","description":""},{"name":"Char.eq_of_val_eq","description":""},{"name":"Char.val_eq_of_eq","description":""},{"name":"Char.ne_of_val_ne","description":""},{"name":"Char.val_ne_of_ne","description":""},{"name":"instDecidableEqChar","description":""},{"name":"Char.utf8Size","description":""},{"name":"Option","description":""},{"name":"instInhabitedOption","description":""},{"name":"Option.getD","description":""},{"name":"List","description":""},{"name":"instInhabitedList","description":""},{"name":"List.hasDecEq","description":""},{"name":"instDecidableEqList","description":""},{"name":"List.foldl","description":""},{"name":"List.set","description":""},{"name":"List.length","description":""},{"name":"List.lengthTRAux","description":""},{"name":"List.lengthTR","description":""},{"name":"List.length_cons","description":""},{"name":"List.concat","description":""},{"name":"List.get","description":""},{"name":"String","description":""},{"name":"String.decEq","description":""},{"name":"instDecidableEqString","description":""},{"name":"String.Pos","description":"A byte position in a `String`. Internally, `String`s are UTF-8 encoded.\nCodepoint positions (counting the Unicode codepoints rather than bytes)\nare represented by plain `Nat`s instead.\nIndexing a `String` by a byte position is constant-time, while codepoint\npositions need to be translated internally to byte positions in linear-time. "},{"name":"Substring","description":""},{"name":"instInhabitedSubstring","description":""},{"name":"Substring.bsize","description":""},{"name":"String.csize","description":""},{"name":"String.utf8ByteSize","description":""},{"name":"String.bsize","description":""},{"name":"String.toSubstring","description":""},{"name":"unsafeCast","description":""},{"name":"panicCore","description":""},{"name":"panic","description":""},{"name":"Array","description":""},{"name":"Array.mkEmpty","description":""},{"name":"Array.empty","description":""},{"name":"Array.size","description":""},{"name":"Array.get","description":""},{"name":"Array.getD","description":""},{"name":"Array.get!","description":""},{"name":"Array.getOp","description":""},{"name":"Array.push","description":""},{"name":"Array.set","description":""},{"name":"Array.setD","description":""},{"name":"Array.set!","description":""},{"name":"Array.appendCore","description":""},{"name":"Array.appendCore.loop","description":""},{"name":"List.toArrayAux","description":""},{"name":"List.redLength","description":""},{"name":"List.toArray","description":""},{"name":"Bind","description":""},{"name":"Pure","description":""},{"name":"Functor","description":""},{"name":"Seq","description":""},{"name":"SeqLeft","description":""},{"name":"SeqRight","description":""},{"name":"Applicative","description":""},{"name":"Monad","description":""},{"name":"instInhabitedForAll_2","description":""},{"name":"instInhabited","description":""},{"name":"Array.sequenceMap","description":""},{"name":"Array.sequenceMap.loop","description":""},{"name":"MonadLift","description":"A Function for lifting a computation from an inner Monad to an outer Monad.\n    Like [MonadTrans](https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Class.html),\n    but `n` does not have to be a monad transformer.\n    Alternatively, an implementation of [MonadLayer](https://hackage.haskell.org/package/layers-0.1/docs/Control-Monad-Layer.html#t:MonadLayer) without `layerInvmap` (so far). "},{"name":"MonadLiftT","description":"The reflexive-transitive closure of `MonadLift`.\n    `monadLift` is used to transitively lift monadic computations such as `StateT.get` or `StateT.put s`.\n    Corresponds to [MonadLift](https://hackage.haskell.org/package/layers-0.1/docs/Control-Monad-Layer.html#t:MonadLift). "},{"name":"liftM","description":""},{"name":"instMonadLiftT","description":""},{"name":"instMonadLiftT_1","description":""},{"name":"MonadFunctor","description":"A functor in the category of monads. Can be used to lift monad-transforming functions.\n    Based on pipes' [MFunctor](https://hackage.haskell.org/package/pipes-2.4.0/docs/Control-MFunctor.html),\n    but not restricted to monad transformers.\n    Alternatively, an implementation of [MonadTransFunctor](http://duairc.netsoc.ie/layers-docs/Control-Monad-Layer.html#t:MonadTransFunctor). "},{"name":"MonadFunctorT","description":"The reflexive-transitive closure of `MonadFunctor`.\n    `monadMap` is used to transitively lift Monad morphisms "},{"name":"instMonadFunctorT","description":""},{"name":"monadFunctorRefl","description":""},{"name":"Except","description":""},{"name":"instInhabitedExcept","description":""},{"name":"MonadExceptOf","description":"An implementation of [MonadError](https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Except.html#t:MonadError) "},{"name":"throwThe","description":""},{"name":"tryCatchThe","description":""},{"name":"MonadExcept","description":"Similar to `MonadExceptOf`, but `ε` is an outParam for convenience "},{"name":"instMonadExcept","description":""},{"name":"MonadExcept.orElse","description":""},{"name":"MonadExcept.instOrElse","description":""},{"name":"ReaderT","description":"An implementation of [ReaderT](https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Reader.html#t:ReaderT) "},{"name":"instInhabitedReaderT","description":""},{"name":"ReaderT.run","description":""},{"name":"ReaderT.instMonadLiftReaderT","description":""},{"name":"ReaderT.instMonadExceptOfReaderT","description":""},{"name":"ReaderT.read","description":""},{"name":"ReaderT.pure","description":""},{"name":"ReaderT.bind","description":""},{"name":"ReaderT.map","description":""},{"name":"ReaderT.instMonadReaderT","description":""},{"name":"ReaderT.instMonadFunctorReaderT","description":""},{"name":"ReaderT.adapt","description":""},{"name":"MonadReaderOf","description":"An implementation of [MonadReader](https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader-Class.html#t:MonadReader).\n    It does not contain `local` because this Function cannot be lifted using `monadLift`.\n    Instead, the `MonadReaderAdapter` class provides the more general `adaptReader` Function.\n\n    Note: This class can be seen as a simplification of the more \"principled\" definition\n    ```\n    class MonadReader (ρ : outParam (Type u)) (n : Type u → Type u) where\n      lift {α : Type u} : ({m : Type u → Type u} → [Monad m] → ReaderT ρ m α) → n α\n    ```\n    "},{"name":"readThe","description":""},{"name":"MonadReader","description":"Similar to `MonadReaderOf`, but `ρ` is an outParam for convenience "},{"name":"instMonadReader","description":""},{"name":"instMonadReaderOf","description":""},{"name":"instMonadReaderOfReaderT","description":""},{"name":"MonadWithReaderOf","description":""},{"name":"withTheReader","description":""},{"name":"MonadWithReader","description":""},{"name":"instMonadWithReader","description":""},{"name":"instMonadWithReaderOf","description":""},{"name":"instMonadWithReaderOfReaderT","description":""},{"name":"MonadStateOf","description":"An implementation of [MonadState](https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Class.html).\n    In contrast to the Haskell implementation, we use overlapping instances to derive instances\n    automatically from `monadLift`. "},{"name":"getThe","description":""},{"name":"modifyThe","description":""},{"name":"modifyGetThe","description":""},{"name":"MonadState","description":"Similar to `MonadStateOf`, but `σ` is an outParam for convenience "},{"name":"instMonadState","description":""},{"name":"modify","description":""},{"name":"getModify","description":""},{"name":"instMonadStateOf","description":""},{"name":"EStateM.Result","description":""},{"name":"EStateM.instInhabitedResult","description":""},{"name":"EStateM","description":""},{"name":"EStateM.instInhabitedEStateM","description":""},{"name":"EStateM.pure","description":""},{"name":"EStateM.set","description":""},{"name":"EStateM.get","description":""},{"name":"EStateM.modifyGet","description":""},{"name":"EStateM.throw","description":""},{"name":"EStateM.Backtrackable","description":"Auxiliary instance for saving/restoring the \"backtrackable\" part of the state. "},{"name":"EStateM.tryCatch","description":""},{"name":"EStateM.orElse","description":""},{"name":"EStateM.adaptExcept","description":""},{"name":"EStateM.bind","description":""},{"name":"EStateM.map","description":""},{"name":"EStateM.seqRight","description":""},{"name":"EStateM.instMonadEStateM","description":""},{"name":"EStateM.instOrElseEStateM","description":""},{"name":"EStateM.instMonadStateOfEStateM","description":""},{"name":"EStateM.instMonadExceptOfEStateM","description":""},{"name":"EStateM.run","description":""},{"name":"EStateM.run'","description":""},{"name":"EStateM.dummySave","description":""},{"name":"EStateM.dummyRestore","description":""},{"name":"EStateM.nonBacktrackable","description":""},{"name":"Hashable","description":""},{"name":"UInt64.toUSize","description":""},{"name":"USize.toUInt64","description":""},{"name":"mixHash","description":""},{"name":"String.hash","description":""},{"name":"instHashableString","description":""},{"name":"Lean.Name","description":""},{"name":"Lean.instInhabitedName","description":""},{"name":"Lean.Name.hash","description":""},{"name":"Lean.instHashableName","description":""},{"name":"Lean.Name.mkStr","description":""},{"name":"Lean.Name.mkNum","description":""},{"name":"Lean.Name.mkSimple","description":""},{"name":"Lean.Name.beq","description":""},{"name":"Lean.Name.instBEqName","description":""},{"name":"Lean.Name.append","description":""},{"name":"Lean.Name.instAppendName","description":""},{"name":"Lean.SourceInfo","description":"Source information of tokens. "},{"name":"Lean.instInhabitedSourceInfo","description":""},{"name":"Lean.SourceInfo.getPos?","description":""},{"name":"Lean.SyntaxNodeKind","description":""},{"name":"Lean.Syntax","description":"Syntax objects used by the parser, macro expander, delaborator, etc.\n"},{"name":"Lean.instInhabitedSyntax","description":""},{"name":"Lean.choiceKind","description":""},{"name":"Lean.nullKind","description":""},{"name":"Lean.groupKind","description":""},{"name":"Lean.identKind","description":""},{"name":"Lean.strLitKind","description":""},{"name":"Lean.charLitKind","description":""},{"name":"Lean.numLitKind","description":""},{"name":"Lean.scientificLitKind","description":""},{"name":"Lean.nameLitKind","description":""},{"name":"Lean.fieldIdxKind","description":""},{"name":"Lean.interpolatedStrLitKind","description":""},{"name":"Lean.interpolatedStrKind","description":""},{"name":"Lean.Syntax.getKind","description":""},{"name":"Lean.Syntax.setKind","description":""},{"name":"Lean.Syntax.isOfKind","description":""},{"name":"Lean.Syntax.getArg","description":""},{"name":"Lean.Syntax.getOp","description":""},{"name":"Lean.Syntax.getArgs","description":""},{"name":"Lean.Syntax.getNumArgs","description":""},{"name":"Lean.Syntax.isMissing","description":""},{"name":"Lean.Syntax.isNodeOf","description":""},{"name":"Lean.Syntax.isIdent","description":""},{"name":"Lean.Syntax.getId","description":""},{"name":"Lean.Syntax.matchesNull","description":""},{"name":"Lean.Syntax.matchesIdent","description":""},{"name":"Lean.Syntax.matchesLit","description":""},{"name":"Lean.Syntax.setArgs","description":""},{"name":"Lean.Syntax.setArg","description":""},{"name":"Lean.Syntax.getHeadInfo?","description":"Retrieve the left-most node or leaf's info in the Syntax tree. "},{"name":"Lean.Syntax.getHeadInfo?.loop","description":""},{"name":"Lean.Syntax.getHeadInfo","description":"Retrieve the left-most leaf's info in the Syntax tree, or `none` if there is no token. "},{"name":"Lean.Syntax.getPos?","description":""},{"name":"Lean.Syntax.getTailPos?","description":""},{"name":"Lean.Syntax.getTailPos?.loop","description":""},{"name":"Lean.Syntax.SepArray","description":"An array of syntax elements interspersed with separators. Can be coerced to/from `Array Syntax` to automatically\n  remove/insert the separators. "},{"name":"Lean.SourceInfo.fromRef","description":""},{"name":"Lean.mkAtom","description":""},{"name":"Lean.mkAtomFrom","description":""},{"name":"Lean.ParserDescr","description":""},{"name":"Lean.instInhabitedParserDescr","description":""},{"name":"Lean.TrailingParserDescr","description":""},{"name":"Lean.MacroScope","description":""},{"name":"Lean.reservedMacroScope","description":"Macro scope used internally. It is not available for our frontend. "},{"name":"Lean.firstFrontendMacroScope","description":"First macro scope available for our frontend "},{"name":"Lean.MonadRef","description":""},{"name":"Lean.instMonadRef","description":""},{"name":"Lean.replaceRef","description":""},{"name":"Lean.withRef","description":""},{"name":"Lean.MonadQuotation","description":"A monad that supports syntax quotations. Syntax quotations (in term\n    position) are monadic values that when executed retrieve the current \"macro\n    scope\" from the monad and apply it to every identifier they introduce\n    (independent of whether this identifier turns out to be a reference to an\n    existing declaration, or an actually fresh binding during further\n    elaboration). We also apply the position of the result of `getRef` to each\n    introduced symbol, which results in better error positions than not applying\n    any position. "},{"name":"Lean.MonadRef.mkInfoFromRefPos","description":""},{"name":"Lean.instMonadQuotation","description":""},{"name":"Lean.Name.hasMacroScopes","description":""},{"name":"Lean.Name.eraseMacroScopes","description":""},{"name":"Lean.Name.simpMacroScopes","description":""},{"name":"Lean.MacroScopesView","description":""},{"name":"Lean.instInhabitedMacroScopesView","description":""},{"name":"Lean.MacroScopesView.review","description":""},{"name":"Lean.extractMacroScopes","description":"Revert all `addMacroScope` calls. `v = extractMacroScopes n → n = v.review`.\n  This operation is useful for analyzing/transforming the original identifiers, then adding back\n  the scopes (via `MacroScopesView.review`). "},{"name":"Lean.addMacroScope","description":""},{"name":"Lean.MonadQuotation.addMacroScope","description":""},{"name":"Lean.defaultMaxRecDepth","description":""},{"name":"Lean.maxRecDepthErrorMessage","description":""},{"name":"Lean.Macro.instNonemptyMethodsRef","description":""},{"name":"Lean.Macro.Context","description":""},{"name":"Lean.Macro.Exception","description":""},{"name":"Lean.Macro.State","description":""},{"name":"Lean.Macro.instInhabitedState","description":""},{"name":"Lean.MacroM","description":""},{"name":"Lean.Macro","description":""},{"name":"Lean.Macro.instMonadRefMacroM","description":""},{"name":"Lean.Macro.addMacroScope","description":""},{"name":"Lean.Macro.throwUnsupported","description":""},{"name":"Lean.Macro.throwError","description":""},{"name":"Lean.Macro.throwErrorAt","description":""},{"name":"Lean.Macro.withFreshMacroScope","description":""},{"name":"Lean.Macro.withIncRecDepth","description":""},{"name":"Lean.Macro.instMonadQuotationMacroM","description":""},{"name":"Lean.Macro.Methods","description":""},{"name":"Lean.Macro.instInhabitedMethods","description":""},{"name":"Lean.Macro.mkMethodsImp","description":""},{"name":"Lean.Macro.mkMethods","description":""},{"name":"Lean.Macro.instInhabitedMethodsRef","description":""},{"name":"Lean.Macro.getMethodsImp","description":""},{"name":"Lean.Macro.getMethods","description":""},{"name":"Lean.Macro.expandMacro?","description":"`expandMacro? stx` return `some stxNew` if `stx` is a macro, and `stxNew` is its expansion. "},{"name":"Lean.Macro.hasDecl","description":"Return `true` if the environment contains a declaration with name `declName` "},{"name":"Lean.Macro.getCurrNamespace","description":""},{"name":"Lean.Macro.resolveNamespace?","description":""},{"name":"Lean.Macro.resolveGlobalName","description":""},{"name":"Lean.Macro.trace","description":""},{"name":"Lean.PrettyPrinter.UnexpandM","description":""},{"name":"Lean.PrettyPrinter.Unexpander","description":"Function that tries to reverse macro expansions as a post-processing step of delaboration.\n  While less general than an arbitrary delaborator, it can be declared without importing `Lean`.\n  Used by the `[appUnexpander]` attribute. "},{"name":"Lean.PrettyPrinter.instMonadQuotationUnexpandM","description":""},{"name":"instToBoolOption","description":""},{"name":"OptionT","description":""},{"name":"OptionT.run","description":""},{"name":"OptionT.mk","description":""},{"name":"OptionT.bind","description":""},{"name":"OptionT.pure","description":""},{"name":"OptionT.instMonadOptionT","description":""},{"name":"OptionT.orElse","description":""},{"name":"OptionT.fail","description":""},{"name":"OptionT.instAlternativeOptionT","description":""},{"name":"OptionT.lift","description":""},{"name":"OptionT.instMonadLiftOptionT","description":""},{"name":"OptionT.instMonadFunctorOptionT","description":""},{"name":"OptionT.tryCatch","description":""},{"name":"OptionT.instMonadExceptOfUnitOptionT","description":""},{"name":"OptionT.instMonadExceptOfOptionT","description":""},{"name":"OptionM","description":""},{"name":"OptionM.run","description":""},{"name":"instMonadControlOptionT","description":""},{"name":"liftOption","description":""},{"name":"UInt8.ofNat","description":""},{"name":"Nat.toUInt8","description":""},{"name":"UInt8.toNat","description":""},{"name":"UInt8.add","description":""},{"name":"UInt8.sub","description":""},{"name":"UInt8.mul","description":""},{"name":"UInt8.div","description":""},{"name":"UInt8.mod","description":""},{"name":"UInt8.modn","description":""},{"name":"UInt8.land","description":""},{"name":"UInt8.lor","description":""},{"name":"UInt8.xor","description":""},{"name":"UInt8.shiftLeft","description":""},{"name":"UInt8.shiftRight","description":""},{"name":"UInt8.lt","description":""},{"name":"UInt8.le","description":""},{"name":"instOfNatUInt8","description":""},{"name":"instAddUInt8","description":""},{"name":"instSubUInt8","description":""},{"name":"instMulUInt8","description":""},{"name":"instModUInt8","description":""},{"name":"instHModUInt8Nat","description":""},{"name":"instDivUInt8","description":""},{"name":"instLTUInt8","description":""},{"name":"instLEUInt8","description":""},{"name":"UInt8.complement","description":""},{"name":"instComplementUInt8","description":""},{"name":"instAndOpUInt8","description":""},{"name":"instOrOpUInt8","description":""},{"name":"instXorUInt8","description":""},{"name":"instShiftLeftUInt8","description":""},{"name":"instShiftRightUInt8","description":""},{"name":"UInt8.decLt","description":""},{"name":"UInt8.decLe","description":""},{"name":"instDecidableLtUInt8InstLTUInt8","description":""},{"name":"instDecidableLeUInt8InstLEUInt8","description":""},{"name":"UInt16.ofNat","description":""},{"name":"Nat.toUInt16","description":""},{"name":"UInt16.toNat","description":""},{"name":"UInt16.add","description":""},{"name":"UInt16.sub","description":""},{"name":"UInt16.mul","description":""},{"name":"UInt16.div","description":""},{"name":"UInt16.mod","description":""},{"name":"UInt16.modn","description":""},{"name":"UInt16.land","description":""},{"name":"UInt16.lor","description":""},{"name":"UInt16.xor","description":""},{"name":"UInt16.shiftLeft","description":""},{"name":"UInt16.toUInt8","description":""},{"name":"UInt8.toUInt16","description":""},{"name":"UInt16.shiftRight","description":""},{"name":"UInt16.lt","description":""},{"name":"UInt16.le","description":""},{"name":"instOfNatUInt16","description":""},{"name":"instAddUInt16","description":""},{"name":"instSubUInt16","description":""},{"name":"instMulUInt16","description":""},{"name":"instModUInt16","description":""},{"name":"instHModUInt16Nat","description":""},{"name":"instDivUInt16","description":""},{"name":"instLTUInt16","description":""},{"name":"instLEUInt16","description":""},{"name":"UInt16.complement","description":""},{"name":"instComplementUInt16","description":""},{"name":"instAndOpUInt16","description":""},{"name":"instOrOpUInt16","description":""},{"name":"instXorUInt16","description":""},{"name":"instShiftLeftUInt16","description":""},{"name":"instShiftRightUInt16","description":""},{"name":"UInt16.decLt","description":""},{"name":"UInt16.decLe","description":""},{"name":"instDecidableLtUInt16InstLTUInt16","description":""},{"name":"instDecidableLeUInt16InstLEUInt16","description":""},{"name":"UInt32.ofNat","description":""},{"name":"UInt32.ofNat'","description":""},{"name":"Nat.toUInt32","description":""},{"name":"UInt32.add","description":""},{"name":"UInt32.sub","description":""},{"name":"UInt32.mul","description":""},{"name":"UInt32.div","description":""},{"name":"UInt32.mod","description":""},{"name":"UInt32.modn","description":""},{"name":"UInt32.land","description":""},{"name":"UInt32.lor","description":""},{"name":"UInt32.xor","description":""},{"name":"UInt32.shiftLeft","description":""},{"name":"UInt32.shiftRight","description":""},{"name":"UInt32.toUInt8","description":""},{"name":"UInt32.toUInt16","description":""},{"name":"UInt8.toUInt32","description":""},{"name":"UInt16.toUInt32","description":""},{"name":"instOfNatUInt32","description":""},{"name":"instAddUInt32","description":""},{"name":"instSubUInt32","description":""},{"name":"instMulUInt32","description":""},{"name":"instModUInt32","description":""},{"name":"instHModUInt32Nat","description":""},{"name":"instDivUInt32","description":""},{"name":"UInt32.complement","description":""},{"name":"instComplementUInt32","description":""},{"name":"instAndOpUInt32","description":""},{"name":"instOrOpUInt32","description":""},{"name":"instXorUInt32","description":""},{"name":"instShiftLeftUInt32","description":""},{"name":"instShiftRightUInt32","description":""},{"name":"UInt64.ofNat","description":""},{"name":"Nat.toUInt64","description":""},{"name":"UInt64.toNat","description":""},{"name":"UInt64.add","description":""},{"name":"UInt64.sub","description":""},{"name":"UInt64.mul","description":""},{"name":"UInt64.div","description":""},{"name":"UInt64.mod","description":""},{"name":"UInt64.modn","description":""},{"name":"UInt64.land","description":""},{"name":"UInt64.lor","description":""},{"name":"UInt64.xor","description":""},{"name":"UInt64.shiftLeft","description":""},{"name":"UInt64.shiftRight","description":""},{"name":"UInt64.lt","description":""},{"name":"UInt64.le","description":""},{"name":"UInt64.toUInt8","description":""},{"name":"UInt64.toUInt16","description":""},{"name":"UInt64.toUInt32","description":""},{"name":"UInt8.toUInt64","description":""},{"name":"UInt16.toUInt64","description":""},{"name":"UInt32.toUInt64","description":""},{"name":"instOfNatUInt64","description":""},{"name":"instAddUInt64","description":""},{"name":"instSubUInt64","description":""},{"name":"instMulUInt64","description":""},{"name":"instModUInt64","description":""},{"name":"instHModUInt64Nat","description":""},{"name":"instDivUInt64","description":""},{"name":"instLTUInt64","description":""},{"name":"instLEUInt64","description":""},{"name":"UInt64.complement","description":""},{"name":"instComplementUInt64","description":""},{"name":"instAndOpUInt64","description":""},{"name":"instOrOpUInt64","description":""},{"name":"instXorUInt64","description":""},{"name":"instShiftLeftUInt64","description":""},{"name":"instShiftRightUInt64","description":""},{"name":"Bool.toUInt64","description":""},{"name":"UInt64.decLt","description":""},{"name":"UInt64.decLe","description":""},{"name":"instDecidableLtUInt64InstLTUInt64","description":""},{"name":"instDecidableLeUInt64InstLEUInt64","description":""},{"name":"usize_size_gt_zero","description":""},{"name":"USize.ofNat","description":""},{"name":"Nat.toUSize","description":""},{"name":"USize.toNat","description":""},{"name":"USize.add","description":""},{"name":"USize.sub","description":""},{"name":"USize.mul","description":""},{"name":"USize.div","description":""},{"name":"USize.mod","description":""},{"name":"USize.modn","description":""},{"name":"USize.land","description":""},{"name":"USize.lor","description":""},{"name":"USize.xor","description":""},{"name":"USize.shiftLeft","description":""},{"name":"USize.shiftRight","description":""},{"name":"UInt32.toUSize","description":""},{"name":"USize.toUInt32","description":""},{"name":"USize.lt","description":""},{"name":"USize.le","description":""},{"name":"instOfNatUSize","description":""},{"name":"instAddUSize","description":""},{"name":"instSubUSize","description":""},{"name":"instMulUSize","description":""},{"name":"instModUSize","description":""},{"name":"instHModUSizeNat","description":""},{"name":"instDivUSize","description":""},{"name":"instLTUSize","description":""},{"name":"instLEUSize","description":""},{"name":"USize.complement","description":""},{"name":"instComplementUSize","description":""},{"name":"instAndOpUSize","description":""},{"name":"instOrOpUSize","description":""},{"name":"instXorUSize","description":""},{"name":"instShiftLeftUSize","description":""},{"name":"instShiftRightUSize","description":""},{"name":"USize.decLt","description":""},{"name":"USize.decLe","description":""},{"name":"instDecidableLtUSizeInstLTUSize","description":""},{"name":"instDecidableLeUSizeInstLEUSize","description":""},{"name":"USize.modn_lt","description":""}]